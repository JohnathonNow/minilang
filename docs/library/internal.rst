internal
========

.. include:: <isonum.txt>

:mini:`type generictype < type`

:mini:`meth :parents(Arg₁: generictype)`

:mini:`type nil < function, sequence`

:mini:`type some`

:mini:`type blank`

:mini:`meth MLCompilerSwitch(Arg₁: function)`

:mini:`meth MLCompilerSwitch(Arg₁: type)`

:mini:`type typeswitch < function`

:mini:`fun mltypeswitch()`

:mini:`type cfunction < function`

:mini:`type cfunctionx < function`

:mini:`type cfunctionz < function`

:mini:`type int32 < integer`

:mini:`type int64 < integer`

:mini:`type double < real`

:mini:`meth MLSequenceCount(Arg₁: integerrange)`

:mini:`meth MLSequenceCount(Arg₁: realrange)`

:mini:`type integerswitch < function`

:mini:`fun mlintegerswitch()`

:mini:`type realswitch < function`

:mini:`fun mlrealswitch()`

:mini:`type tableiter`

:mini:`type tablerowiter`

:mini:`type stringiterator`

:mini:`type stringswitch < function`

:mini:`fun mlstringswitch()`

:mini:`type doublediterator < sequence`

:mini:`type doublediteratorstate < state`

:mini:`type stacked < sequence`

:mini:`type stackedstate`

:mini:`type repeated < sequence`

:mini:`type repeatedstate`

:mini:`type sequenced < sequence`

:mini:`type sequencedstate`

:mini:`type limited < sequence`

:mini:`meth :count(Arg₁: limited)`

:mini:`type limitedstate`

:mini:`type skipped < sequence`

:mini:`type buffered < sequence`

:mini:`type bufferedstate`

:mini:`type unique < sequence`

:mini:`type uniquestate`

:mini:`type zipped < sequence`

:mini:`type zippedstate`

:mini:`type paired < sequence`

:mini:`type pairedstate`

:mini:`type weaved < sequence`

:mini:`type weavedstate`

:mini:`type swapped < sequence`

:mini:`type swappedstate`

:mini:`type key < sequence`

:mini:`type keystate`

:mini:`type errorvalue`

:mini:`type field`

:mini:`type namedtype < type`

:mini:`type enumvalue < int64`

:mini:`type enumvalue < integer`

:mini:`type enumswitch < function`

:mini:`meth MLCompilerSwitch(Arg₁: enum)`

:mini:`type enumiter`

:mini:`type flagsvalue < int64`

:mini:`type flagsvalue < integer`

:mini:`type flagsswitch < function`

:mini:`meth MLCompilerSwitch(Arg₁: flags)`

:mini:`meth MLSequenceCount(Arg₁: map)`

:mini:`type mapindex`

:mini:`meth MLSequenceCount(Arg₁: list)`

:mini:`type listiter`

:mini:`type names`

:mini:`type TypelibIterT`

:mini:`fun defaulttagfn()`

:mini:`type DEBUG_TYPE < Continuation`

:mini:`meth :jit(Arg₁: closure)`

:mini:`type arrayiterator`

:mini:`fun mltest(Arg₁: string, Arg₂: any)`

