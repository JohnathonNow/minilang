internal
========

:mini:`type generictype < type`
   *TBD*

:mini:`meth :parents(Arg₁: generictype)`
   *TBD*

:mini:`type nil < function, sequence`
   *TBD*

:mini:`type some`
   *TBD*

:mini:`type blank`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: function)`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: type)`
   *TBD*

:mini:`type typeswitch < function`
   *TBD*

:mini:`fun mltypeswitch()`
   *TBD*

:mini:`type cfunction < function`
   *TBD*

:mini:`type cfunctionx < function`
   *TBD*

:mini:`type cfunctionz < function`
   *TBD*

:mini:`type int32 < integer`
   *TBD*

:mini:`type int64 < integer`
   *TBD*

:mini:`type double < real`
   *TBD*

:mini:`meth :MLSequenceCount(Arg₁: integerrange)`
   *TBD*

:mini:`meth :MLSequenceCount(Arg₁: realrange)`
   *TBD*

:mini:`type integerswitch < function`
   *TBD*

:mini:`fun mlintegerswitch()`
   *TBD*

:mini:`type realswitch < function`
   *TBD*

:mini:`fun mlrealswitch()`
   *TBD*

:mini:`type tableiter`
   *TBD*

:mini:`type tablerowiter`
   *TBD*

:mini:`meth :MLSequenceCount(Arg₁: address)`
   *TBD*

:mini:`type stringiterator`
   *TBD*

:mini:`type stringswitch < function`
   *TBD*

:mini:`fun mlchained(Arg₁: any)`
   *TBD*

:mini:`type chainedstate`
   *TBD*

:mini:`type doublediterator < sequence`
   *TBD*

:mini:`type doublediteratorstate < state`
   *TBD*

:mini:`type stacked < sequence`
   *TBD*

:mini:`type stackedstate`
   *TBD*

:mini:`type repeated < sequence`
   *TBD*

:mini:`type repeatedstate`
   *TBD*

:mini:`type sequenced < sequence`
   *TBD*

:mini:`type sequencedstate`
   *TBD*

:mini:`type limited < sequence`
   *TBD*

:mini:`meth :count(Arg₁: limited)`
   *TBD*

:mini:`type limitedstate`
   *TBD*

:mini:`type skipped < sequence`
   *TBD*

:mini:`type buffered < sequence`
   *TBD*

:mini:`type bufferedstate`
   *TBD*

:mini:`type unique < sequence`
   *TBD*

:mini:`type uniquestate`
   *TBD*

:mini:`type zipped < sequence`
   *TBD*

:mini:`type zippedstate`
   *TBD*

:mini:`type paired < sequence`
   *TBD*

:mini:`type pairedstate`
   *TBD*

:mini:`type weaved < sequence`
   *TBD*

:mini:`type weavedstate`
   *TBD*

:mini:`type folded < sequence`
   *TBD*

:mini:`type foldedstate`
   *TBD*

:mini:`type unfolded < sequence`
   *TBD*

:mini:`type unfoldedstate`
   *TBD*

:mini:`type swapped < sequence`
   *TBD*

:mini:`type swappedstate`
   *TBD*

:mini:`type key < sequence`
   *TBD*

:mini:`type keystate`
   *TBD*

:mini:`type batched < sequence`
   *TBD*

:mini:`type batchedstate`
   *TBD*

:mini:`type field`
   *TBD*

:mini:`type namedtype < type`
   *TBD*

:mini:`type enumvalue < int64`
   *TBD*

:mini:`type enumvalue < integer`
   *TBD*

:mini:`type enumswitch < function`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: enum)`
   *TBD*

:mini:`type enumiter`
   *TBD*

:mini:`type flagsvalue < int64`
   *TBD*

:mini:`type flagsvalue < integer`
   *TBD*

:mini:`type flagsswitch < function`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: flags)`
   *TBD*

:mini:`type methodswitch < function`
   *TBD*

:mini:`fun mlmethodswitch()`
   *TBD*

:mini:`meth :MLSequenceCount(Arg₁: map)`
   *TBD*

:mini:`type mapindex`
   *TBD*

:mini:`meth :MLSequenceCount(Arg₁: list)`
   *TBD*

:mini:`type listiter`
   *TBD*

:mini:`type names`
   *TBD*

:mini:`type TypelibIterT`
   *TBD*

:mini:`fun defaulttagfn()`
   *TBD*

:mini:`type DEBUG_TYPE < Continuation`
   *TBD*

:mini:`meth :jit(Arg₁: closure)`
   *TBD*

:mini:`type arrayiterator`
   *TBD*

:mini:`fun mltest(Arg₁: string, Arg₂: any)`
   *TBD*

