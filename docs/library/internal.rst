internal
========

:mini:`type generic::type < type`
   *TBD*

:mini:`meth :parents(Arg₁: generic::type)`
   *TBD*

:mini:`type nil < function, sequence`
   *TBD*

:mini:`type some`
   *TBD*

:mini:`type blank`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: function)`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: type)`
   *TBD*

:mini:`type type::switch < function`
   *TBD*

:mini:`fun mltypeswitch()`
   *TBD*

:mini:`type cfunction < function`
   *TBD*

:mini:`type cfunctionx < function`
   *TBD*

:mini:`type cfunctionz < function`
   *TBD*

:mini:`type int32 < integer`
   *TBD*

:mini:`type int64 < integer`
   *TBD*

:mini:`type double < real`
   *TBD*

:mini:`meth :count(Arg₁: integer::range)`
   *TBD*

:mini:`meth :count(Arg₁: real::range)`
   *TBD*

:mini:`type integer::switch < function`
   *TBD*

:mini:`fun mlintegerswitch()`
   *TBD*

:mini:`type real::switch < function`
   *TBD*

:mini:`fun mlrealswitch()`
   *TBD*

:mini:`type table::iter`
   *TBD*

:mini:`type table::row`
   *TBD*

:mini:`type string::iterator`
   *TBD*

:mini:`type string::switch < function`
   *TBD*

:mini:`fun mlchained(Arg₁: any)`
   *TBD*

:mini:`type chained::state`
   *TBD*

:mini:`type doubled::iterator < sequence`
   *TBD*

:mini:`type doubled::iterator < state`
   *TBD*

:mini:`type stacked < sequence`
   *TBD*

:mini:`type stacked::state`
   *TBD*

:mini:`type repeated < sequence`
   *TBD*

:mini:`type repeated::state`
   *TBD*

:mini:`type sequenced < sequence`
   *TBD*

:mini:`type sequenced::state`
   *TBD*

:mini:`type limited < sequence`
   *TBD*

:mini:`meth :count(Arg₁: limited)`
   *TBD*

:mini:`type limited::state`
   *TBD*

:mini:`type skipped < sequence`
   *TBD*

:mini:`type buffered < sequence`
   *TBD*

:mini:`type buffered::state`
   *TBD*

:mini:`type unique < sequence`
   *TBD*

:mini:`type unique::state`
   *TBD*

:mini:`type zipped < sequence`
   *TBD*

:mini:`type zipped::state`
   *TBD*

:mini:`type paired < sequence`
   *TBD*

:mini:`type paired::state`
   *TBD*

:mini:`type weaved < sequence`
   *TBD*

:mini:`type weaved::state`
   *TBD*

:mini:`type folded < sequence`
   *TBD*

:mini:`type folded::state`
   *TBD*

:mini:`type unfolded < sequence`
   *TBD*

:mini:`type unfolded::state`
   *TBD*

:mini:`type swapped < sequence`
   *TBD*

:mini:`type swapped::state`
   *TBD*

:mini:`type key < sequence`
   *TBD*

:mini:`type key::state`
   *TBD*

:mini:`type batched < sequence`
   *TBD*

:mini:`type batched::state`
   *TBD*

:mini:`type field`
   *TBD*

:mini:`type named::type < type`
   *TBD*

:mini:`type enum::value < int64`
   *TBD*

:mini:`type enum::value < integer`
   *TBD*

:mini:`type enum::switch < function`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: enum)`
   *TBD*

:mini:`type enum::iter`
   *TBD*

:mini:`type flags::value < int64`
   *TBD*

:mini:`type flags::value < integer`
   *TBD*

:mini:`type flags::switch < function`
   *TBD*

:mini:`meth :MLCompilerSwitch(Arg₁: flags)`
   *TBD*

:mini:`type method::switch < function`
   *TBD*

:mini:`fun mlmethodswitch()`
   *TBD*

:mini:`meth :count(Arg₁: map)`
   *TBD*

:mini:`type map::index`
   *TBD*

:mini:`type list::iter`
   *TBD*

:mini:`type names`
   *TBD*

:mini:`type TypelibIterT`
   *TBD*

:mini:`fun defaulttagfn()`
   *TBD*

:mini:`type DEBUG_TYPE < Continuation`
   *TBD*

:mini:`meth :jit(Arg₁: closure)`
   *TBD*

:mini:`type array::iterator`
   *TBD*

:mini:`fun mltest(Arg₁: string, Arg₂: any)`
   *TBD*

