
hierarchy
=========

.. graphviz::

   digraph hierarchy {
      rankdir="LR";
      fontsize="40pt"
      concentrate=true;
      overlap=false;
      packMode="node";
      outputorder="edgesfirst";
      node [shape=box,fontsize=24];
      "any":e -> "sequence":w;
      "any":e -> "function":w;
      "(MLFunction":e -> "type":w;
      "(MLFunction":e -> "visitor":w;
      "(mlfunction":e -> "function::partial":w;
      "MLSequence":e -> "function::partial":w;
      "(mlfunction":e -> "tuple":w;
      "MLSequence":e -> "tuple":w;
      "any":e -> "boolean":w;
      "any":e -> "module":w;
      "any":e -> "external":w;
      "any":e -> "external::set":w;
      "(MLFunction":e -> "symbol":w;
      "any":e -> "symbol::interval":w;
      "any":e -> "weakref":w;
      "any":e -> "weakmaptoken":w;
      "any":e -> "weakmap":w;
      "any":e -> "xml":w;
      "(mlxml":e -> "xml::text":w;
      "MLString":e -> "xml::text":w;
      "(mlxml":e -> "xml::element":w;
      "MLSequence":e -> "xml::element":w;
      "(MLFunction":e -> "xml::filter":w;
      "(MLStream":e -> "xml::parser":w;
      "(MLSequence":e -> "xe::node":w;
      "any":e -> "xe::var":w;
      "any":e -> "uuid":w;
      "any":e -> "time":w;
      "enum::cyclic":e -> "time::day":w;
      "enum::cyclic":e -> "time::month":w;
      "any":e -> "time::zone":w;
      "any":e -> "thread":w;
      "(MLFunction":e -> "thread::port":w;
      "any":e -> "thread::channel":w;
      "any":e -> "thread::mutex":w;
      "any":e -> "thread::protected":w;
      "any":e -> "thread::condition":w;
      "(MLFunction":e -> "task":w;
      "(MLTask":e -> "task::set":w;
      "(MLFunction":e -> "task::queue":w;
      "(MLSequence":e -> "table":w;
      "(MLSequence":e -> "table::row":w;
      "any":e -> "instance::field":w;
      "any":e -> "instance":w;
      "(MLFunction":e -> "struct::getter":w;
      "(MLFunction":e -> "struct::getter::fast":w;
      "(MLType":e -> "struct":w;
      "any":e -> "ref":w;
      "any":e -> "address":w;
      "(MLAddress":e -> "buffer":w;
      "(mladdress":e -> "string":w;
      "MLSequence":e -> "string":w;
      "enum":e -> "string::norm":w;
      "enum":e -> "string::ctype":w;
      "(MLFunction":e -> "regex":w;
      "(MLStream":e -> "string::buffer":w;
      "any":e -> "stream":w;
      "enum":e -> "stream::seek":w;
      "(mlfunction":e -> "stream::parser":w;
      "MLSequence":e -> "stream::parser":w;
      "(MLStream":e -> "stream::buffered":w;
      "(MLStream":e -> "stream::fd":w;
      "enum":e -> "socket::type":w;
      "(MLStreamFd":e -> "socket":w;
      "(MLSocket":e -> "socket::local":w;
      "(MLSocket":e -> "socket::inet":w;
      "(MLSequence":e -> "set":w;
      "(MLSet":e -> "set::mutable":w;
      "enum":e -> "set::order":w;
      "(mlfunction":e -> "chained":w;
      "MLSequence":e -> "chained":w;
      "any":e -> "iterator":w;
      "(MLSequence":e -> "split":w;
      "(MLSequence":e -> "grouped":w;
      "(MLFunction":e -> "context":w;
      "(MLFunction":e -> "state":w;
      "(MLState":e -> "resumable::state":w;
      "any":e -> "uninitialized":w;
      "any":e -> "error":w;
      "any":e -> "error::value":w;
      "any":e -> "debugger":w;
      "any":e -> "semaphore":w;
      "any":e -> "condition":w;
      "any":e -> "rwlock":w;
      "any":e -> "channel":w;
      "any":e -> "pqueue::entry":w;
      "(MLSequence":e -> "pqueue":w;
      "(MLFunction":e -> "polynomial":w;
      "any":e -> "polynomial::rational":w;
      "any":e -> "field":w;
      "(MLField":e -> "field::mutable":w;
      "any":e -> "object":w;
      "(MLType":e -> "class":w;
      "any":e -> "property":w;
      "(MLInteger":e -> "enum::value":w;
      "(mltype":e -> "enum":w;
      "MLSequence":e -> "enum":w;
      "(MLEnum":e -> "enum::cyclic":w;
      "(MLSequence":e -> "enum::interval":w;
      "(MLType":e -> "flags":w;
      "any":e -> "flags::value":w;
      "any":e -> "flags::spec":w;
      "any":e -> "number":w;
      "(MLNumber":e -> "complex":w;
      "(MLComplex":e -> "real":w;
      "(mlreal":e -> "integer":w;
      "MLFunction":e -> "integer":w;
      "(MLReal":e -> "double":w;
      "(MLSequence":e -> "integer::range":w;
      "(MLSequence":e -> "integer::interval":w;
      "(MLSequence":e -> "real::range":w;
      "(MLSequence":e -> "real::interval":w;
      "(MLAddress":e -> "mmap":w;
      "(mlmmap":e -> "mmap::buffer":w;
      "MLBuffer":e -> "mmap::buffer":w;
      "any":e -> "minijs":w;
      "any":e -> "method::context":w;
      "(MLFunction":e -> "method":w;
      "(MLFunction":e -> "random":w;
      "(MLSequence":e -> "map":w;
      "(MLMap":e -> "map::mutable":w;
      "enum":e -> "map::order":w;
      "any":e -> "map::node":w;
      "(MLMapNode":e -> "map::node::mutable":w;
      "any":e -> "map::node::mutable":w;
      "(MLFunction":e -> "log::macro":w;
      "any":e -> "logger":w;
      "(MLSequence":e -> "list":w;
      "(MLList":e -> "list::mutable":w;
      "any":e -> "list::node":w;
      "(MLListNode":e -> "list::node::mutable":w;
      "any":e -> "list::node::mutable":w;
      "any":e -> "list::slice":w;
      "(MLSequence":e -> "list::skip":w;
      "(MLFunction":e -> "importer":w;
      "any":e -> "module::dir":w;
      "(MLStream":e -> "json::decoder":w;
      "(MLString":e -> "json":w;
      "(MLSequence":e -> "gir":w;
      "(MLType":e -> "gir::baseinfo":w;
      "any":e -> "gir::module":w;
      "(GirBaseInfo":e -> "gir::object":w;
      "any":e -> "gir::objectinstance":w;
      "(GirBaseInfo":e -> "gir::struct":w;
      "any":e -> "gir::structinstance":w;
      "(GirBaseInfo":e -> "gir::union":w;
      "any":e -> "gir::unioninstance":w;
      "any":e -> "gir::fieldref":w;
      "(GirFieldRef":e -> "gir::fieldref-boolean":w;
      "(GirFieldRef":e -> "gir::fieldref-int8":w;
      "(GirFieldRef":e -> "gir::fieldref-uint8":w;
      "(GirFieldRef":e -> "gir::fieldref-int16":w;
      "(GirFieldRef":e -> "gir::fieldref-uint16":w;
      "(GirFieldRef":e -> "gir::fieldref-int32":w;
      "(GirFieldRef":e -> "gir::fieldref-uint32":w;
      "(GirFieldRef":e -> "gir::fieldref-int64":w;
      "(GirFieldRef":e -> "gir::fieldref-uint64":w;
      "(GirFieldRef":e -> "gir::fieldref-float":w;
      "(GirFieldRef":e -> "gir::fieldref-double":w;
      "(GirFieldRef":e -> "gir::fieldref-utf8":w;
      "(GirBaseInfo":e -> "gir::enum":w;
      "any":e -> "gir::enumvalue":w;
      "any":e -> "gir::objectproperty":w;
      "any":e -> "gir::instance":w;
      "(GirBaseInfo":e -> "gir::callback":w;
      "any":e -> "gir::callbackinstance":w;
      "(MLFunction":e -> "gir::function":w;
      "(MLStream":e -> "file":w;
      "any":e -> "file::stat":w;
      "enum":e -> "file::mode":w;
      "(MLSequence":e -> "dir":w;
      "(MLFile":e -> "popen":w;
      "(MLState":e -> "compiler::function":w;
      "any":e -> "expr":w;
      "any":e -> "macro":w;
      "(MLFunction":e -> "function::inline":w;
      "(MLFunction":e -> "macro::subst":w;
      "any":e -> "block::builder":w;
      "any":e -> "expr::builder":w;
      "(MLState":e -> "compiler":w;
      "any":e -> "parser":w;
      "any":e -> "global":w;
      "(MLStream":e -> "cbor::decoder":w;
      "any":e -> "cbortag":w;
      "any":e -> "variable":w;
      "(mlstate":e -> "continuation":w;
      "MLSequence":e -> "continuation":w;
      "(mlfunction":e -> "closure":w;
      "MLSequence":e -> "closure":w;
      "any":e -> "closure::info":w;
      "any":e -> "ast::expr":w;
      "(AstExpr":e -> "ast::expr::if":w;
      "(AstExpr":e -> "ast::expr::fun":w;
      "(AstExpr":e -> "ast::expr::for":w;
      "(AstExpr":e -> "ast::expr::value":w;
      "(AstExpr":e -> "ast::expr::subst":w;
      "(AstExpr":e -> "ast::expr::ident":w;
      "(AstExpr":e -> "ast::expr::local":w;
      "(AstExpr":e -> "ast::expr::block":w;
      "(AstExpr":e -> "ast::expr::string":w;
      "(AstExpr":e -> "ast::expr::scoped":w;
      "(AstExpr":e -> "ast::expr::parent":w;
      "(AstExpr":e -> "ast::expr::default":w;
      "(AstExpr":e -> "ast::expr::ifconfig":w;
      "(AstExpr":e -> "ast::expr::parentvalue":w;
      "(AstParentExpr":e -> "ast::expr::and":w;
      "(AstParentExpr":e -> "ast::expr::assign":w;
      "(AstExpr":e -> "ast::expr::blank":w;
      "(AstParentExpr":e -> "ast::expr::call":w;
      "(AstParentValueExpr":e -> "ast::expr::constcall":w;
      "(AstParentExpr":e -> "ast::expr::debug":w;
      "(AstLocalExpr":e -> "ast::expr::def":w;
      "(AstLocalExpr":e -> "ast::expr::defin":w;
      "(AstLocalExpr":e -> "ast::expr::defunpack":w;
      "(AstIdentExpr":e -> "ast::expr::define":w;
      "(AstParentExpr":e -> "ast::expr::delegate":w;
      "(AstParentExpr":e -> "ast::expr::each":w;
      "(AstParentExpr":e -> "ast::expr::exit":w;
      "(AstParentExpr":e -> "ast::expr::guard":w;
      "(AstParentExpr":e -> "ast::expr::inline":w;
      "(AstExpr":e -> "ast::expr::it":w;
      "(AstLocalExpr":e -> "ast::expr::let":w;
      "(AstLocalExpr":e -> "ast::expr::letin":w;
      "(AstLocalExpr":e -> "ast::expr::letunpack":w;
      "(AstParentExpr":e -> "ast::expr::list":w;
      "(AstParentExpr":e -> "ast::expr::loop":w;
      "(AstParentExpr":e -> "ast::expr::map":w;
      "(AstParentExpr":e -> "ast::expr::next":w;
      "(AstExpr":e -> "ast::expr::nil":w;
      "(AstParentExpr":e -> "ast::expr::not":w;
      "(AstExpr":e -> "ast::expr::old":w;
      "(AstParentExpr":e -> "ast::expr::or":w;
      "(AstLocalExpr":e -> "ast::expr::ref":w;
      "(AstLocalExpr":e -> "ast::expr::refin":w;
      "(AstLocalExpr":e -> "ast::expr::refunpack":w;
      "(AstExpr":e -> "ast::expr::register":w;
      "(AstParentValueExpr":e -> "ast::expr::resolve":w;
      "(AstParentExpr":e -> "ast::expr::return":w;
      "(AstParentExpr":e -> "ast::expr::suspend":w;
      "(AstParentExpr":e -> "ast::expr::switch":w;
      "(AstParentExpr":e -> "ast::expr::tuple":w;
      "(AstExpr":e -> "ast::expr::unknown":w;
      "(AstLocalExpr":e -> "ast::expr::var":w;
      "(AstLocalExpr":e -> "ast::expr::varin":w;
      "(AstLocalExpr":e -> "ast::expr::vartype":w;
      "(AstLocalExpr":e -> "ast::expr::varunpack":w;
      "(AstLocalExpr":e -> "ast::expr::with":w;
      "any":e -> "ast::local":w;
      "any":e -> "ast::param":w;
      "any":e -> "ast::stringpart":w;
      "any":e -> "ast::ifcase":w;
      "enum":e -> "paramkind":w;
      "(MLList":e -> "ast::names":w;
      "(mladdress":e -> "array":w;
      "MLSequence":e -> "array":w;
      "(mlarray":e -> "array::mutable":w;
      "MLBuffer":e -> "array::mutable":w;
      "(MLArray":e -> "vector":w;
      "(mlvector":e -> "vector::mutable":w;
      "MLArrayMutable":e -> "vector::mutable":w;
      "(MLArray":e -> "matrix":w;
      "(mlmatrix":e -> "matrix::mutable":w;
      "MLArrayMutable":e -> "matrix::mutable":w;
      "(MLArray":e -> "array::complex":w;
      "(mlarraycomplex":e -> "array::mutable::complex":w;
      "MLArrayMutable":e -> "array::mutable::complex":w;
      "(mlarraycomplex":e -> "vector::complex":w;
      "MLVector":e -> "vector::complex":w;
      "(mlvectorcomplex":e -> "vector::mutable::complex":w;
      "array::mutable::complex":e -> "vector::mutable::complex":w;
      "MLVectorMutable":e -> "vector::mutable::complex":w;
      "(mlarraycomplex":e -> "matrix::complex":w;
      "MLMatrix":e -> "matrix::complex":w;
      "(mlarraymutablecomplex":e -> "matrix::mutable::complex":w;
      "MLMatrixMutable":e -> "matrix::mutable::complex":w;
      "(MLArrayComplex":e -> "array::real":w;
      "(mlarrayreal":e -> "array::mutable::real":w;
      "MLArrayMutableComplex":e -> "array::mutable::real":w;
      "(mlarrayreal":e -> "vector::real":w;
      "MLVectorComplex":e -> "vector::real":w;
      "(mlvectorreal":e -> "vector::mutable::real":w;
      "array::mutable::real":e -> "vector::mutable::real":w;
      "MLVectorMutableComplex":e -> "vector::mutable::real":w;
      "(mlarrayreal":e -> "matrix::real":w;
      "MLMatrixComplex":e -> "matrix::real":w;
      "(mlmatrixreal":e -> "matrix::mutable::real":w;
      "array::mutable::real":e -> "matrix::mutable::real":w;
      "MLMatrixMutableComplex":e -> "matrix::mutable::real":w;
      "(MLArrayReal":e -> "array::integer":w;
      "(mlarrayinteger":e -> "array::mutable::integer":w;
      "MLArrayMutableReal":e -> "array::mutable::integer":w;
      "(MLVectorReal":e -> "vector::integer":w;
      "(mlvectorinteger":e -> "vector::mutable::integer":w;
      "MLVectorMutableReal":e -> "vector::mutable::integer":w;
      "(MLMatrixReal":e -> "matrix::integer":w;
      "(mlmatrixinteger":e -> "matrix::mutable::integer":w;
      "MLMatrixMutableReal":e -> "matrix::mutable::integer":w;
      "any":e -> "ref::uint8":w;
      "any":e -> "ref::int8":w;
      "any":e -> "ref::uint16":w;
      "any":e -> "ref::int16":w;
      "any":e -> "ref::uint32":w;
      "any":e -> "ref::int32":w;
      "any":e -> "ref::uint64":w;
      "any":e -> "ref::int64":w;
      "any":e -> "ref::float32":w;
      "any":e -> "ref::float64":w;
      "any":e -> "ref::complex32":w;
      "any":e -> "ref::complex64":w;
      "any":e -> "ref::any":w;
      "any":e -> "array::iterator":w;
      "(MLArrayIterator":e -> "array::mutable::iterator":w;
      "(MLArrayPAREN":e -> "array::uint8":w;
      "(mlarrayuint8":e -> "array::mutable::uint8":w;
      "MLArrayMutablePAREN":e -> "array::mutable::uint8":w;
      "(mlvectorinteger":e -> "vector::uint8":w;
      "MLArraySUFFI":e -> "vector::uint8":w;
      "(mlvectoruint8":e -> "vector::mutable::uint8":w;
      "vector::mutable::integer":e -> "vector::mutable::uint8":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::uint8":w;
      "(mlmatrixinteger":e -> "matrix::uint8":w;
      "MLArraySUFFI":e -> "matrix::uint8":w;
      "(mlmatrixuint8":e -> "matrix::mutable::uint8":w;
      "matrix::mutable::integer":e -> "matrix::mutable::uint8":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::uint8":w;
      "(MLArrayPAREN":e -> "array::int8":w;
      "(mlarrayint8":e -> "array::mutable::int8":w;
      "MLArrayMutablePAREN":e -> "array::mutable::int8":w;
      "(mlvectorinteger":e -> "vector::int8":w;
      "MLArraySUFFI":e -> "vector::int8":w;
      "(mlvectorint8":e -> "vector::mutable::int8":w;
      "vector::mutable::integer":e -> "vector::mutable::int8":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::int8":w;
      "(mlmatrixinteger":e -> "matrix::int8":w;
      "MLArraySUFFI":e -> "matrix::int8":w;
      "(mlmatrixint8":e -> "matrix::mutable::int8":w;
      "matrix::mutable::integer":e -> "matrix::mutable::int8":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::int8":w;
      "(MLArrayPAREN":e -> "array::uint16":w;
      "(mlarrayuint16":e -> "array::mutable::uint16":w;
      "MLArrayMutablePAREN":e -> "array::mutable::uint16":w;
      "(mlvectorinteger":e -> "vector::uint16":w;
      "MLArraySUFFI":e -> "vector::uint16":w;
      "(mlvectoruint16":e -> "vector::mutable::uint16":w;
      "vector::mutable::integer":e -> "vector::mutable::uint16":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::uint16":w;
      "(mlmatrixinteger":e -> "matrix::uint16":w;
      "MLArraySUFFI":e -> "matrix::uint16":w;
      "(mlmatrixuint16":e -> "matrix::mutable::uint16":w;
      "matrix::mutable::integer":e -> "matrix::mutable::uint16":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::uint16":w;
      "(MLArrayPAREN":e -> "array::int16":w;
      "(mlarrayint16":e -> "array::mutable::int16":w;
      "MLArrayMutablePAREN":e -> "array::mutable::int16":w;
      "(mlvectorinteger":e -> "vector::int16":w;
      "MLArraySUFFI":e -> "vector::int16":w;
      "(mlvectorint16":e -> "vector::mutable::int16":w;
      "vector::mutable::integer":e -> "vector::mutable::int16":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::int16":w;
      "(mlmatrixinteger":e -> "matrix::int16":w;
      "MLArraySUFFI":e -> "matrix::int16":w;
      "(mlmatrixint16":e -> "matrix::mutable::int16":w;
      "matrix::mutable::integer":e -> "matrix::mutable::int16":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::int16":w;
      "(MLArrayPAREN":e -> "array::uint32":w;
      "(mlarrayuint32":e -> "array::mutable::uint32":w;
      "MLArrayMutablePAREN":e -> "array::mutable::uint32":w;
      "(mlvectorinteger":e -> "vector::uint32":w;
      "MLArraySUFFI":e -> "vector::uint32":w;
      "(mlvectoruint32":e -> "vector::mutable::uint32":w;
      "vector::mutable::integer":e -> "vector::mutable::uint32":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::uint32":w;
      "(mlmatrixinteger":e -> "matrix::uint32":w;
      "MLArraySUFFI":e -> "matrix::uint32":w;
      "(mlmatrixuint32":e -> "matrix::mutable::uint32":w;
      "matrix::mutable::integer":e -> "matrix::mutable::uint32":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::uint32":w;
      "(MLArrayPAREN":e -> "array::int32":w;
      "(mlarrayint32":e -> "array::mutable::int32":w;
      "MLArrayMutablePAREN":e -> "array::mutable::int32":w;
      "(mlvectorinteger":e -> "vector::int32":w;
      "MLArraySUFFI":e -> "vector::int32":w;
      "(mlvectorint32":e -> "vector::mutable::int32":w;
      "vector::mutable::integer":e -> "vector::mutable::int32":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::int32":w;
      "(mlmatrixinteger":e -> "matrix::int32":w;
      "MLArraySUFFI":e -> "matrix::int32":w;
      "(mlmatrixint32":e -> "matrix::mutable::int32":w;
      "matrix::mutable::integer":e -> "matrix::mutable::int32":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::int32":w;
      "(MLArrayPAREN":e -> "array::uint64":w;
      "(mlarrayuint64":e -> "array::mutable::uint64":w;
      "MLArrayMutablePAREN":e -> "array::mutable::uint64":w;
      "(mlvectorinteger":e -> "vector::uint64":w;
      "MLArraySUFFI":e -> "vector::uint64":w;
      "(mlvectoruint64":e -> "vector::mutable::uint64":w;
      "vector::mutable::integer":e -> "vector::mutable::uint64":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::uint64":w;
      "(mlmatrixinteger":e -> "matrix::uint64":w;
      "MLArraySUFFI":e -> "matrix::uint64":w;
      "(mlmatrixuint64":e -> "matrix::mutable::uint64":w;
      "matrix::mutable::integer":e -> "matrix::mutable::uint64":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::uint64":w;
      "(MLArrayPAREN":e -> "array::int64":w;
      "(mlarrayint64":e -> "array::mutable::int64":w;
      "MLArrayMutablePAREN":e -> "array::mutable::int64":w;
      "(mlvectorinteger":e -> "vector::int64":w;
      "MLArraySUFFI":e -> "vector::int64":w;
      "(mlvectorint64":e -> "vector::mutable::int64":w;
      "vector::mutable::integer":e -> "vector::mutable::int64":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::int64":w;
      "(mlmatrixinteger":e -> "matrix::int64":w;
      "MLArraySUFFI":e -> "matrix::int64":w;
      "(mlmatrixint64":e -> "matrix::mutable::int64":w;
      "matrix::mutable::integer":e -> "matrix::mutable::int64":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::int64":w;
      "(MLArrayPAREN":e -> "array::float32":w;
      "(mlarrayfloat32":e -> "array::mutable::float32":w;
      "MLArrayMutablePAREN":e -> "array::mutable::float32":w;
      "(mlvectorreal":e -> "vector::float32":w;
      "MLArraySUFFI":e -> "vector::float32":w;
      "(mlvectorfloat32":e -> "vector::mutable::float32":w;
      "vector::mutable::real":e -> "vector::mutable::float32":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::float32":w;
      "(mlmatrixreal":e -> "matrix::float32":w;
      "MLArraySUFFI":e -> "matrix::float32":w;
      "(mlmatrixfloat32":e -> "matrix::mutable::float32":w;
      "matrix::mutable::real":e -> "matrix::mutable::float32":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::float32":w;
      "(MLArrayPAREN":e -> "array::float64":w;
      "(mlarrayfloat64":e -> "array::mutable::float64":w;
      "MLArrayMutablePAREN":e -> "array::mutable::float64":w;
      "(mlvectorreal":e -> "vector::float64":w;
      "MLArraySUFFI":e -> "vector::float64":w;
      "(mlvectorfloat64":e -> "vector::mutable::float64":w;
      "vector::mutable::real":e -> "vector::mutable::float64":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::float64":w;
      "(mlmatrixreal":e -> "matrix::float64":w;
      "MLArraySUFFI":e -> "matrix::float64":w;
      "(mlmatrixfloat64":e -> "matrix::mutable::float64":w;
      "matrix::mutable::real":e -> "matrix::mutable::float64":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::float64":w;
      "(MLArrayPAREN":e -> "array::complex32":w;
      "(mlarraycomplex32":e -> "array::mutable::complex32":w;
      "MLArrayMutablePAREN":e -> "array::mutable::complex32":w;
      "(mlvectorcomplex":e -> "vector::complex32":w;
      "MLArraySUFFI":e -> "vector::complex32":w;
      "(mlvectorcomplex32":e -> "vector::mutable::complex32":w;
      "vector::mutable::complex":e -> "vector::mutable::complex32":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::complex32":w;
      "(mlmatrixcomplex":e -> "matrix::complex32":w;
      "MLArraySUFFI":e -> "matrix::complex32":w;
      "(mlmatrixcomplex32":e -> "matrix::mutable::complex32":w;
      "matrix::mutable::complex":e -> "matrix::mutable::complex32":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::complex32":w;
      "(MLArrayPAREN":e -> "array::complex64":w;
      "(mlarraycomplex64":e -> "array::mutable::complex64":w;
      "MLArrayMutablePAREN":e -> "array::mutable::complex64":w;
      "(mlvectorcomplex":e -> "vector::complex64":w;
      "MLArraySUFFI":e -> "vector::complex64":w;
      "(mlvectorcomplex64":e -> "vector::mutable::complex64":w;
      "vector::mutable::complex":e -> "vector::mutable::complex64":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::complex64":w;
      "(mlmatrixcomplex":e -> "matrix::complex64":w;
      "MLArraySUFFI":e -> "matrix::complex64":w;
      "(mlmatrixcomplex64":e -> "matrix::mutable::complex64":w;
      "matrix::mutable::complex":e -> "matrix::mutable::complex64":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::complex64":w;
      "(MLArrayPAREN":e -> "array::any":w;
      "(mlarrayany":e -> "array::mutable::any":w;
      "MLArrayMutablePAREN":e -> "array::mutable::any":w;
      "(mlvector":e -> "vector::any":w;
      "MLArraySUFFI":e -> "vector::any":w;
      "(mlvectorany":e -> "vector::mutable::any":w;
      "vector::mutable":e -> "vector::mutable::any":w;
      "MLArrayMutableSUFFI":e -> "vector::mutable::any":w;
      "(mlmatrix":e -> "matrix::any":w;
      "MLArraySUFFI":e -> "matrix::any":w;
      "(mlmatrixany":e -> "matrix::mutable::any":w;
      "matrix::mutable":e -> "matrix::mutable::any":w;
      "MLArrayMutableSUFFI":e -> "matrix::mutable::any":w;
   }

