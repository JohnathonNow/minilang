<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.10.0" xml:lang="en-US">
  <compounddef id="ml__list_8c" kind="file" language="C++">
    <compoundname>ml_list.c</compoundname>
    <includes refid="ml__list_8h" local="yes">ml_list.h</includes>
    <includes refid="minilang_8h" local="yes">minilang.h</includes>
    <includes refid="ml__macros_8h" local="yes">ml_macros.h</includes>
    <includes local="no">string.h</includes>
    <includes refid="ml__sequence_8h" local="yes">ml_sequence.h</includes>
    <includes local="yes">ml_list_init.c</includes>
    <incdepgraph>
      <node id="14">
        <label>inthash.h</label>
        <link refid="inthash_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>minilang.h</label>
        <link refid="minilang_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>ml_compiler.h</label>
        <link refid="ml__compiler_8h_source"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/ml_list.c</label>
        <link refid="ml__list_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>ml_list.h</label>
        <link refid="ml__list_8h_source"/>
      </node>
      <node id="18">
        <label>ml_macros.h</label>
        <link refid="ml__macros_8h_source"/>
        <childnode refid="19" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>ml_runtime.h</label>
        <link refid="ml__runtime_8h_source"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="20">
        <label>ml_sequence.h</label>
        <link refid="ml__sequence_8h_source"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>ml_types.h</label>
        <link refid="ml__types_8h_source"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>stringmap.h</label>
        <link refid="stringmap_8h_source"/>
      </node>
      <node id="19">
        <label>gc/gc.h</label>
      </node>
      <node id="17">
        <label>limits.h</label>
      </node>
      <node id="16">
        <label>ml_config.h</label>
      </node>
      <node id="21">
        <label>ml_list_init.c</label>
      </node>
      <node id="7">
        <label>setjmp.h</label>
      </node>
      <node id="12">
        <label>stdarg.h</label>
      </node>
      <node id="15">
        <label>stdint.h</label>
      </node>
      <node id="10">
        <label>stdio.h</label>
      </node>
      <node id="4">
        <label>stdlib.h</label>
      </node>
      <node id="11">
        <label>string.h</label>
      </node>
      <node id="5">
        <label>unistd.h</label>
      </node>
    </incdepgraph>
    <innerclass refid="structml__list__filter__state__t" prot="public">ml_list_filter_state_t</innerclass>
    <innerclass refid="structml__list__slice__t" prot="public">ml_list_slice_t</innerclass>
    <innerclass refid="structml__list__compare__state__t" prot="public">ml_list_compare_state_t</innerclass>
    <innerclass refid="structml__list__skip__t" prot="public">ml_list_skip_t</innerclass>
    <innerclass refid="structml__list__sort__state__t" prot="public">ml_list_sort_state_t</innerclass>
    <innerclass refid="structml__list__find__state__t" prot="public">ml_list_find_state_t</innerclass>
    <innerclass refid="structml__list__remove__state__t" prot="public">ml_list_remove_state_t</innerclass>
    <innerclass refid="structml__permutations__t" prot="public">ml_permutations_t</innerclass>
    <innerclass refid="structml__list__visit__t" prot="public">ml_list_visit_t</innerclass>
    <sectiondef kind="define">
      <memberdef kind="define" id="ml__list_8c_1aebec330325aff5cbc7d9c9248e2cae4a" prot="public" static="no">
        <name>ML_CATEGORY</name>
        <initializer>&quot;list&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="8" column="10" bodyfile="src/ml_list.c" bodystart="8" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ml__list_8c_1af190880a593303f6bcd871ce830f65d6" prot="public" static="no">
        <name>MLListMutableT</name>
        <initializer>MLListT</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="58" column="10" bodyfile="src/ml_list.c" bodystart="58" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ml__list_8c_1a9ebd7c9dcc6e752effe0da49860b450d" prot="public" static="no">
        <name>MLListNodeMutableT</name>
        <initializer>MLListNodeT</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="113" column="9" bodyfile="src/ml_list.c" bodystart="113" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="ml__list_8c_1a4116291fc89fd5fb4d9868f0fd736194" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * EqualMethod</definition>
        <argsstring></argsstring>
        <name>EqualMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="662" column="19" bodyfile="src/ml_list.c" bodystart="1528" bodyend="-1" declfile="src/ml_list.c" declline="662" declcolumn="19"/>
      </memberdef>
      <memberdef kind="variable" id="ml__list_8c_1a922a052040a31465cfd3fe54ecbacd05" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * LessMethod</definition>
        <argsstring></argsstring>
        <name>LessMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="663" column="19" bodyfile="src/ml_list.c" bodystart="1474" bodyend="-1" declfile="src/ml_list.c" declline="663" declcolumn="19"/>
      </memberdef>
      <memberdef kind="variable" id="ml__list_8c_1adb6d8320cdbce2c8d4f52936c1f81390" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t* GreaterMethod</definition>
        <argsstring></argsstring>
        <name>GreaterMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="664" column="19" declfile="src/ml_list.c" declline="664" declcolumn="19"/>
      </memberdef>
      <memberdef kind="variable" id="ml__list_8c_1a8e0e135c2ed8f4b5ad61798cc29029ad" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t* NotEqualMethod</definition>
        <argsstring></argsstring>
        <name>NotEqualMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="665" column="19" declfile="src/ml_list.c" declline="665" declcolumn="19"/>
      </memberdef>
      <memberdef kind="variable" id="ml__list_8c_1a5b3059703b4ccac5d3bc6ea9cc33469b" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t* LessEqualMethod</definition>
        <argsstring></argsstring>
        <name>LessEqualMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="666" column="19" declfile="src/ml_list.c" declline="666" declcolumn="19"/>
      </memberdef>
      <memberdef kind="variable" id="ml__list_8c_1a320ed3e705279b7244b114a07a0f220f" prot="public" static="no" extern="yes" mutable="no">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t* GreaterEqualMethod</definition>
        <argsstring></argsstring>
        <name>GreaterEqualMethod</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="667" column="19" declfile="src/ml_list.c" declline="667" declcolumn="19"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="ml__list_8c_1aa9f0c2649e15777d3b21c11dd60673b4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
        <definition>static ml_list_node_t * ml_list_index</definition>
        <argsstring>(ml_list_t *List, int Index)</argsstring>
        <name>ml_list_index</name>
        <param>
          <type><ref refid="structml__list__t" kindref="compound">ml_list_t</ref> *</type>
          <declname>List</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="10" column="23" bodyfile="src/ml_list.c" bodystart="10" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a2b4e525963e3777a319526003ac87d44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLListT,(MLSequenceT), &quot;list&quot;)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>(MLSequenceT)</type>
        </param>
        <param>
          <type>&quot;list&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="51" column="1" declfile="src/ml_list.c" declline="51" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1af3dc2fd21b3391185db1dd25e5354af5" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_value_find_all, MLListT, ml_value_t *Value, void *Data, ml_value_find_fn RefFn)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_value_find_all</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>ml_value_find_fn</type>
          <declname>RefFn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="81" column="13" bodyfile="src/ml_list.c" bodystart="81" bodyend="84"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1acf6884008e8446cef43bc97d80e16538" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>static ml_value_t * ml_list_node_deref</definition>
        <argsstring>(ml_list_node_t *Node)</argsstring>
        <name>ml_list_node_deref</name>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="86" column="19" bodyfile="src/ml_list.c" bodystart="86" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aa609a27656aba563c9b33c3a07fa048a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_node_assign</definition>
        <argsstring>(ml_state_t *Caller, ml_list_node_t *Node, ml_value_t *Value)</argsstring>
        <name>ml_list_node_assign</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="90" column="13" bodyfile="src/ml_list.c" bodystart="90" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a37bd0b03dc867c8e4bbe760c9e910b4a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLListNodeMutableT,(), &quot;list::node&quot;,.deref=(void *) ml_list_node_deref,.assign=(void *) ml_list_node_assign)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLListNodeMutableT</type>
        </param>
        <param>
          <type>()</type>
        </param>
        <param>
          <type>&quot;list::node&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>deref</declname>
          <defval>(void *) ml_list_node_deref</defval>
        </param>
        <param>
          <type>.</type>
          <declname>assign</declname>
          <defval>(void *) ml_list_node_assign</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="115" column="1" declfile="src/ml_list.c" declline="115" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a159049597efcf3b1fef416a3f75ec1be" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_next, MLListNodeT, ml_state_t *Caller, ml_list_node_t *Node)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_next</type>
        </param>
        <param>
          <type>MLListNodeT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="125" column="13" bodyfile="src/ml_list.c" bodystart="125" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1af6b9a76c45a6c4690579fb6aa222d05b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_key, MLListNodeT, ml_state_t *Caller, ml_list_node_t *Node)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_key</type>
        </param>
        <param>
          <type>MLListNodeT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="132" column="13" bodyfile="src/ml_list.c" bodystart="132" bodyend="134"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a607f42a205e984477b14b88d8f3a1bb1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_value, MLListNodeT, ml_state_t *Caller, ml_list_node_t *Node)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_value</type>
        </param>
        <param>
          <type>MLListNodeT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="136" column="13" bodyfile="src/ml_list.c" bodystart="136" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3e9d91069ba5a8df6f7ad89335d9170e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list</definition>
        <argsstring>()</argsstring>
        <name>ml_list</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="140" column="12" bodyfile="src/ml_list.c" bodystart="140" bodyend="146"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ae2bf06293d693906d4ec28e4793ddde4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="148" column="1" bodyfile="src/ml_list.c" bodystart="148" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a1be9dbaab17c303bec6f013de95688ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(MLListT, MLTupleT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLTupleT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="155" column="1" bodyfile="src/ml_list.c" bodystart="155" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a74574c89037c2aa7f95a8231a041eaa5" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void list_iterate</definition>
        <argsstring>(ml_iter_state_t *State, ml_value_t *Value)</argsstring>
        <name>list_iterate</name>
        <param>
          <type><ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="179" column="13" bodyfile="src/ml_list.c" bodystart="179" bodyend="184" declfile="src/ml_list.c" declline="169" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aa968731c32b9d2be1d14064080803c0f" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void list_iter_value</definition>
        <argsstring>(ml_iter_state_t *State, ml_value_t *Value)</argsstring>
        <name>list_iter_value</name>
        <param>
          <type><ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="171" column="13" bodyfile="src/ml_list.c" bodystart="171" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aa415b9370fa49cb63437f713d338624f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODVX</definition>
        <argsstring>(MLListT, MLSequenceT)</argsstring>
        <name>ML_METHODVX</name>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLSequenceT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="186" column="1" bodyfile="src/ml_list.c" bodystart="186" bodyend="197"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a282a1c164a18ef42c9e01aedecbfdb51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODVX</definition>
        <argsstring>(&quot;grow&quot;, MLListMutableT, MLSequenceT)</argsstring>
        <name>ML_METHODVX</name>
        <param>
          <type>&quot;grow&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLSequenceT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="199" column="1" bodyfile="src/ml_list.c" bodystart="199" bodyend="212"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a0ca829765e23522a1b4b53c1d3f0b070" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list_from_array</definition>
        <argsstring>(ml_value_t **Values, int Length)</argsstring>
        <name>ml_list_from_array</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Values</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Length</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="214" column="12" bodyfile="src/ml_list.c" bodystart="214" bodyend="218"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ab24d3b28132776481c0a97bc59608a0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_list_to_array</definition>
        <argsstring>(ml_value_t *List, ml_value_t **Values)</argsstring>
        <name>ml_list_to_array</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Values</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="220" column="6" bodyfile="src/ml_list.c" bodystart="220" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a1aa5a6e666267627f1a809dc97ed404e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_list_grow</definition>
        <argsstring>(ml_value_t *List0, int Count)</argsstring>
        <name>ml_list_grow</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="227" column="6" bodyfile="src/ml_list.c" bodystart="227" bodyend="232"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3b1ce5a0ae327e868e48198650490999" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_list_push</definition>
        <argsstring>(ml_value_t *List0, ml_value_t *Value)</argsstring>
        <name>ml_list_push</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="234" column="6" bodyfile="src/ml_list.c" bodystart="234" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ab4a65cce4afab5666e547da2184b44a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_list_put</definition>
        <argsstring>(ml_value_t *List0, ml_value_t *Value)</argsstring>
        <name>ml_list_put</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="252" column="6" bodyfile="src/ml_list.c" bodystart="252" bodyend="272"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a050cdecdadef1db319d252402bdf23d5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list_pop</definition>
        <argsstring>(ml_value_t *List0)</argsstring>
        <name>ml_list_pop</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="274" column="12" bodyfile="src/ml_list.c" bodystart="274" bodyend="290"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a0275fb873132a4a104e7122ae771ed2c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list_pull</definition>
        <argsstring>(ml_value_t *List0)</argsstring>
        <name>ml_list_pull</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="292" column="12" bodyfile="src/ml_list.c" bodystart="292" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a571e328d43844ea9306fa6e80c32a530" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list_get</definition>
        <argsstring>(ml_value_t *List0, int Index)</argsstring>
        <name>ml_list_get</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="309" column="12" bodyfile="src/ml_list.c" bodystart="309" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a162768b0f2cc1c46d5609f2a3ef414f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_list_set</definition>
        <argsstring>(ml_value_t *List0, int Index, ml_value_t *Value)</argsstring>
        <name>ml_list_set</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List0</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Index</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="314" column="12" bodyfile="src/ml_list.c" bodystart="314" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a600e32c0a936b2e089d2ca529d6cbb50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int ml_list_foreach</definition>
        <argsstring>(ml_value_t *Value, void *Data, int(*callback)(ml_value_t *, void *))</argsstring>
        <name>ml_list_foreach</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>int(*)(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *, void *)</type>
          <declname>callback</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="325" column="5" bodyfile="src/ml_list.c" bodystart="325" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aee740f50889b260a216660502ee2f9f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;precount&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;precount&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="330" column="1" bodyfile="src/ml_list.c" bodystart="330" bodyend="337"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3ca5a3c3f661b3381217a9632d561274" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;count&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;count&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="339" column="1" bodyfile="src/ml_list.c" bodystart="339" bodyend="346"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a72280066a11cfbbcb5b241b34aa11670" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;length&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;length&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="348" column="1" bodyfile="src/ml_list.c" bodystart="348" bodyend="355"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ab21de774411c533e7eba08cbc75691ab" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;first&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;first&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="357" column="1" bodyfile="src/ml_list.c" bodystart="357" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a491b4627b52faf4735b40b861a5b7c32" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;last&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;last&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="364" column="1" bodyfile="src/ml_list.c" bodystart="364" bodyend="369"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a17df61f13dfc9730d1114e7ff4529eb2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_filter_state_run</definition>
        <argsstring>(ml_list_filter_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_filter_state_run</name>
        <param>
          <type><ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="383" column="13" bodyfile="src/ml_list.c" bodystart="383" bodyend="420"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a5e5378da373cd6f17d768e3fe46417fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;filter&quot;, MLListMutableT, MLFunctionT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;filter&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLFunctionT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="422" column="1" bodyfile="src/ml_list.c" bodystart="422" bodyend="447"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a73de9c089058b40c36d23aaf1d00e393" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_remove_state_run</definition>
        <argsstring>(ml_list_filter_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_remove_state_run</name>
        <param>
          <type><ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="449" column="13" bodyfile="src/ml_list.c" bodystart="449" bodyend="486"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aebbb7352afdf79919653071d96c741e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;remove&quot;, MLListMutableT, MLFunctionT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;remove&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLFunctionT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="488" column="1" bodyfile="src/ml_list.c" bodystart="488" bodyend="513"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a91e1cb2d1d7d9f34eb03382ab2e9a49c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;[]&quot;, MLListT, MLIntegerT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;&quot;</type>
          <array>[]</array>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="515" column="1" bodyfile="src/ml_list.c" bodystart="515" bodyend="528"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ade399866b7f04b6904591a78cbaf938b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>static ml_value_t * ml_list_slice_deref</definition>
        <argsstring>(ml_list_slice_t *Slice)</argsstring>
        <name>ml_list_slice_deref</name>
        <param>
          <type><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref> *</type>
          <declname>Slice</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="536" column="19" bodyfile="src/ml_list.c" bodystart="536" bodyend="546"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a872eb7ac832acb952e1cb700d0be7cc6" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_slice_assign</definition>
        <argsstring>(ml_state_t *Caller, ml_list_slice_t *Slice, ml_value_t *Packed)</argsstring>
        <name>ml_list_slice_assign</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref> *</type>
          <declname>Slice</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Packed</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="548" column="13" bodyfile="src/ml_list.c" bodystart="548" bodyend="560"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ac2fdfea9ba8c57466f39c1c4bd8a376c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLListSliceT,(), &quot;list-slice&quot;,.deref=(void *) ml_list_slice_deref,.assign=(void *) ml_list_slice_assign)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLListSliceT</type>
        </param>
        <param>
          <type>()</type>
        </param>
        <param>
          <type>&quot;list-slice&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>deref</declname>
          <defval>(void *) ml_list_slice_deref</defval>
        </param>
        <param>
          <type>.</type>
          <declname>assign</declname>
          <defval>(void *) ml_list_slice_assign</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="562" column="1" declfile="src/ml_list.c" declline="562" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1afae5045acba00e771499bd7da17f1a7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;[]&quot;, MLListMutableT, MLIntegerT, MLIntegerT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;&quot;</type>
          <array>[]</array>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="568" column="1" bodyfile="src/ml_list.c" bodystart="568" bodyend="586"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ab9068fdbe955edc9965c4d6d3e0b2b88" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;[]&quot;, MLListMutableT, MLIntegerRangeT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;&quot;</type>
          <array>[]</array>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerRangeT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="607" column="1" bodyfile="src/ml_list.c" bodystart="607" bodyend="625"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a8adfc35343cf66bfd5c3a456787ed01d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;[]&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;&quot;</type>
          <array>[]</array>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="647" column="1" bodyfile="src/ml_list.c" bodystart="647" bodyend="660"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a956b1294d20db88956eed96cf65c8c3b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_compare_equal_run</definition>
        <argsstring>(ml_list_compare_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_compare_equal_run</name>
        <param>
          <type><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="676" column="13" bodyfile="src/ml_list.c" bodystart="676" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1acddcd01b83fcd3da55d45dac7fc2b626" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;=&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="688" column="1" bodyfile="src/ml_list.c" bodystart="688" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a2463aa8226362d0d116bcb87e3afee66" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_compare_order_run</definition>
        <argsstring>(ml_list_compare_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_compare_order_run</name>
        <param>
          <type><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="771" column="13" bodyfile="src/ml_list.c" bodystart="771" bodyend="779" declfile="src/ml_list.c" declline="756" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1adab26da041b4079a41c51a3f51efab77" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_compare_order2_run</definition>
        <argsstring>(ml_list_compare_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_compare_order2_run</name>
        <param>
          <type><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="758" column="13" bodyfile="src/ml_list.c" bodystart="758" bodyend="769"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aed97088992c9ebaed3939db5ee893c54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;&lt;=&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;&lt;=&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="823" column="1" bodyfile="src/ml_list.c" bodystart="823" bodyend="863"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1abffdafb078ce44cb2659421d8426323c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;&gt;&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;</type>
        </param>
        <param>
          <type>&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="865" column="1" bodyfile="src/ml_list.c" bodystart="865" bodyend="905"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3eaeda07847d9c6e653843b40e82c06c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;&gt;=&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;&gt;=&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="907" column="1" bodyfile="src/ml_list.c" bodystart="907" bodyend="947"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a9b89534d00df4bf17b10222ce672e139" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;append&quot;, MLStringBufferT, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;append&quot;</type>
        </param>
        <param>
          <type>MLStringBufferT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="949" column="1" bodyfile="src/ml_list.c" bodystart="949" bodyend="969"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a9ff7da32bffd41510bfcde7553357e03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;append&quot;, MLStringBufferT, MLListT, MLStringT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;append&quot;</type>
        </param>
        <param>
          <type>MLStringBufferT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLStringT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="971" column="1" bodyfile="src/ml_list.c" bodystart="971" bodyend="992"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a80b5c543f2b2f970cc91c1cc9e0628b2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>static ml_value_t * ML_TYPED_FN</definition>
        <argsstring>(ml_unpack, MLListT, ml_list_t *List, int Index)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_unpack</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type><ref refid="structml__list__t" kindref="compound">ml_list_t</ref> *</type>
          <declname>List</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="994" column="19" bodyfile="src/ml_list.c" bodystart="994" bodyend="996"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a09a6f3e5f166e4e3dd3f69915d1a4699" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iterate, MLListT, ml_state_t *Caller, ml_list_t *List)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iterate</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__t" kindref="compound">ml_list_t</ref> *</type>
          <declname>List</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1025" column="13" bodyfile="src/ml_list.c" bodystart="1025" bodyend="1032"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aff798dada46bfadba7fcdc28577a9c01" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLListSkipT,(MLSequenceT), &quot;list::skip&quot;)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLListSkipT</type>
        </param>
        <param>
          <type>(MLSequenceT)</type>
        </param>
        <param>
          <type>&quot;list::skip&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1040" column="1" declfile="src/ml_list.c" declline="1040" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a97748c68a544eb6d9302dd295af994fb" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iterate, MLListSkipT, ml_state_t *Caller, ml_list_skip_t *Skip)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iterate</type>
        </param>
        <param>
          <type>MLListSkipT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__list__skip__t" kindref="compound">ml_list_skip_t</ref> *</type>
          <declname>Skip</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1042" column="13" bodyfile="src/ml_list.c" bodystart="1042" bodyend="1048"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a9256bb2a06a4db34abfe67480833fcd0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;skip&quot;, MLListT, MLIntegerT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;skip&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>internal</para>
        </inbodydescription>
        <location file="src/ml_list.c" line="1050" column="1" bodyfile="src/ml_list.c" bodystart="1050" bodyend="1057"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a614487b166a2501e69993282fc415f1e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODV</definition>
        <argsstring>(&quot;push&quot;, MLListMutableT)</argsstring>
        <name>ML_METHODV</name>
        <param>
          <type>&quot;push&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1059" column="1" bodyfile="src/ml_list.c" bodystart="1059" bodyend="1067"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a0d4fab5dacdec0029ecbb9844ffb34fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODV</definition>
        <argsstring>(&quot;put&quot;, MLListMutableT)</argsstring>
        <name>ML_METHODV</name>
        <param>
          <type>&quot;put&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1069" column="1" bodyfile="src/ml_list.c" bodystart="1069" bodyend="1077"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a5ed80eb4f848b5419f959d1340c30bb5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;pop&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;pop&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1079" column="1" bodyfile="src/ml_list.c" bodystart="1079" bodyend="1084"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ac91c2dd849f5d43f5c3e6f3ea581ce5a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;pull&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;pull&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1086" column="1" bodyfile="src/ml_list.c" bodystart="1086" bodyend="1091"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3f9827d4ccaa83d2ad1525d560e87eb8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;empty&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;empty&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1093" column="1" bodyfile="src/ml_list.c" bodystart="1093" bodyend="1104"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a454b0dda12baeafa1b3883343f984848" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;+&quot;, MLListT, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;+&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1106" column="1" bodyfile="src/ml_list.c" bodystart="1106" bodyend="1115"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a36f74b9e3c091f67f5d489ddc8f5b8ae" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;splice&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;splice&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1117" column="1" bodyfile="src/ml_list.c" bodystart="1117" bodyend="1127"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a9826c5b54c8ef1b241e60573834993b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;splice&quot;, MLListMutableT, MLIntegerT, MLIntegerT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;splice&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1129" column="1" bodyfile="src/ml_list.c" bodystart="1129" bodyend="1194"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a55dd421f26c1f234f5663bd4467eeecd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;splice&quot;, MLListMutableT, MLIntegerT, MLIntegerT, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;splice&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1196" column="1" bodyfile="src/ml_list.c" bodystart="1196" bodyend="1311"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ae6c89079fff4395a1391fb26a33caa8e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;splice&quot;, MLListMutableT, MLIntegerT, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;splice&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1313" column="1" bodyfile="src/ml_list.c" bodystart="1313" bodyend="1356"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ababd7e9a52d481be8e70c519f899b674" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;reverse&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;reverse&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1358" column="1" bodyfile="src/ml_list.c" bodystart="1358" bodyend="1380"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1accb2bcd44cba5dc51c4ce940fa858922" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_sort_state_run</definition>
        <argsstring>(ml_list_sort_state_t *State, ml_value_t *Result)</argsstring>
        <name>ml_list_sort_state_run</name>
        <param>
          <type><ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1394" column="13" bodyfile="src/ml_list.c" bodystart="1394" bodyend="1472"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a6f7e0febfc4d0147c6a422f4fbf7e074" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;sort&quot;, MLListMutableT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;sort&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1476" column="1" bodyfile="src/ml_list.c" bodystart="1476" bodyend="1496"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a67e9864d09481cf01ebdb55c0ff803c5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;sort&quot;, MLListMutableT, MLFunctionT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;sort&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLFunctionT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1498" column="1" bodyfile="src/ml_list.c" bodystart="1498" bodyend="1519"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a86020fbd3f8f9b9a402b287952290133" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_find_state_run</definition>
        <argsstring>(ml_list_find_state_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_find_state_run</name>
        <param>
          <type><ref refid="structml__list__find__state__t" kindref="compound">ml_list_find_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1530" column="13" bodyfile="src/ml_list.c" bodystart="1530" bodyend="1540"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ac3cff6b1c7713a20e4a2a9dd93eb3aa4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;find&quot;, MLListT, MLAnyT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;find&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLAnyT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1542" column="1" bodyfile="src/ml_list.c" bodystart="1542" bodyend="1558"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a45a12a1a539d96db6d199997a70c4ca3" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_delete</definition>
        <argsstring>(ml_list_t *List, ml_list_node_t *Node)</argsstring>
        <name>ml_list_delete</name>
        <param>
          <type><ref refid="structml__list__t" kindref="compound">ml_list_t</ref> *</type>
          <declname>List</declname>
        </param>
        <param>
          <type><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref> *</type>
          <declname>Node</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1560" column="13" bodyfile="src/ml_list.c" bodystart="1560" bodyend="1569"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1adad154dbe9a0df8f84a1de8ec6231dda" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;delete&quot;, MLListMutableT, MLIntegerT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;delete&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLIntegerT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1571" column="1" bodyfile="src/ml_list.c" bodystart="1571" bodyend="1589"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ad9d719d72444d67a00718fdead295b31" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_pop_state_run</definition>
        <argsstring>(ml_list_remove_state_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_pop_state_run</name>
        <param>
          <type><ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1599" column="13" bodyfile="src/ml_list.c" bodystart="1599" bodyend="1612"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ae940a9c742932b4cd8f3baf7c2acd85c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;pop&quot;, MLListMutableT, MLFunctionT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;pop&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLFunctionT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1614" column="1" bodyfile="src/ml_list.c" bodystart="1614" bodyend="1633"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a72ce2f1a7dee55f2454987815d2cedf4" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_pull_state_run</definition>
        <argsstring>(ml_list_remove_state_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_pull_state_run</name>
        <param>
          <type><ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1635" column="13" bodyfile="src/ml_list.c" bodystart="1635" bodyend="1648"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a867ac6fb055b46e8598e879d5d2ae8a4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;pull&quot;, MLListMutableT, MLFunctionT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;pull&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type>MLFunctionT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1650" column="1" bodyfile="src/ml_list.c" bodystart="1650" bodyend="1669"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a24907c575156160ab9643f706fd9a518" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;permute&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;permute&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>list</para>
        </inbodydescription>
        <location file="src/ml_list.c" line="1671" column="1" bodyfile="src/ml_list.c" bodystart="1671" bodyend="1706"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ad4301d33a3fd7cadf6a4f56a1f4f192d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;shuffle&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;shuffle&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>list</para>
        </inbodydescription>
        <location file="src/ml_list.c" line="1708" column="1" bodyfile="src/ml_list.c" bodystart="1708" bodyend="1739"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a00ef11d286e7086d70fb87e0df5f6b36" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;cycle&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;cycle&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>list</para>
        </inbodydescription>
        <location file="src/ml_list.c" line="1741" column="1" bodyfile="src/ml_list.c" bodystart="1741" bodyend="1770"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a981bf0b6fbb3e8a7e9b43cb3ba10aebb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLPermutationsT,(MLSequenceT), &quot;list::permutations&quot;)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLPermutationsT</type>
        </param>
        <param>
          <type>(MLSequenceT)</type>
        </param>
        <param>
          <type>&quot;list::permutations&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1780" column="1" declfile="src/ml_list.c" declline="1780" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a3e026329991525a5bc3f5d11b10d62eb" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iterate, MLPermutationsT, ml_state_t *Caller, ml_permutations_t *Permutations)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iterate</type>
        </param>
        <param>
          <type>MLPermutationsT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref> *</type>
          <declname>Permutations</declname>
        </param>
        <briefdescription>
<para>internal </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1783" column="13" bodyfile="src/ml_list.c" bodystart="1783" bodyend="1786"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a545b9ac95748e540d78b802a6077fe02" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_next, MLPermutationsT, ml_state_t *Caller, ml_permutations_t *Permutations)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_next</type>
        </param>
        <param>
          <type>MLPermutationsT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref> *</type>
          <declname>Permutations</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1788" column="13" bodyfile="src/ml_list.c" bodystart="1788" bodyend="1818"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1adb0d2d1864ebf74fd6c866e4fc2f4f21" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_key, MLPermutationsT, ml_state_t *Caller, ml_permutations_t *Permutations)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_key</type>
        </param>
        <param>
          <type>MLPermutationsT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref> *</type>
          <declname>Permutations</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1820" column="13" bodyfile="src/ml_list.c" bodystart="1820" bodyend="1822"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a65d4e44dd1a8df76572266de76fa9c74" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_iter_value, MLPermutationsT, ml_state_t *Caller, ml_permutations_t *Permutations)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_iter_value</type>
        </param>
        <param>
          <type>MLPermutationsT</type>
        </param>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref> *</type>
          <declname>Permutations</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1824" column="13" bodyfile="src/ml_list.c" bodystart="1824" bodyend="1826"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1af597b8fcf31ce759875281c0f2a88a69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;permutations&quot;, MLListMutableT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;permutations&quot;</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1828" column="1" bodyfile="src/ml_list.c" bodystart="1828" bodyend="1846"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1aa994fd1435650ce717d1be2b8a7b4550" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;random&quot;, MLListT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;random&quot;</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1848" column="1" bodyfile="src/ml_list.c" bodystart="1848" bodyend="1862"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ad6c51addf2b77b3366c2a219a4a74b06" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_visit_run</definition>
        <argsstring>(ml_list_visit_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_visit_run</name>
        <param>
          <type><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1871" column="13" bodyfile="src/ml_list.c" bodystart="1871" bodyend="1879"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a7352a2e7060a10251b83cd4c8fc9ac40" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;visit&quot;, MLVisitorT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;visit&quot;</type>
        </param>
        <param>
          <type>MLVisitorT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1881" column="1" bodyfile="src/ml_list.c" bodystart="1881" bodyend="1897"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ac1bc22a79895f296346d898cfcdae5ac" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_copy_run</definition>
        <argsstring>(ml_list_visit_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_copy_run</name>
        <param>
          <type><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1899" column="13" bodyfile="src/ml_list.c" bodystart="1899" bodyend="1908"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a87a687c0cccb949caf6b34423487b47b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;copy&quot;, MLVisitorT, MLListT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;copy&quot;</type>
        </param>
        <param>
          <type>MLVisitorT</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1910" column="1" bodyfile="src/ml_list.c" bodystart="1910" bodyend="1929"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ad76143ea84dc95a6e668fdac5c75d594" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_list_const_run</definition>
        <argsstring>(ml_list_visit_t *State, ml_value_t *Value)</argsstring>
        <name>ml_list_const_run</name>
        <param>
          <type><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref> *</type>
          <declname>State</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1931" column="13" bodyfile="src/ml_list.c" bodystart="1931" bodyend="1955"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a59c7e62cc109287e05724ac4117eee63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;const&quot;, MLVisitorT, MLListMutableT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;const&quot;</type>
        </param>
        <param>
          <type>MLVisitorT</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1957" column="1" bodyfile="src/ml_list.c" bodystart="1957" bodyend="1976"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a797e709ef32d46e955e72c2680e274e7" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ML_TYPED_FN</definition>
        <argsstring>(ml_value_is_constant, MLListMutableT, ml_value_t *List)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_value_is_constant</type>
        </param>
        <param>
          <type>MLListMutableT</type>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1978" column="12" bodyfile="src/ml_list.c" bodystart="1978" bodyend="1980"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1af9a2f5539b865cc84a4216a6b19ffa15" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ML_TYPED_FN</definition>
        <argsstring>(ml_value_is_constant, MLListT, ml_value_t *List)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_value_is_constant</type>
        </param>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>List</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1982" column="12" bodyfile="src/ml_list.c" bodystart="1982" bodyend="1987"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a105a7066b2d67b9025133a489053232e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLNamesT,(), &quot;names&quot;,)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLNamesT</type>
        </param>
        <param>
          <type>()</type>
        </param>
        <param>
          <type>&quot;names&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1989" column="1" declfile="src/ml_list.c" declline="1989" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a7d99e731e1c61f6fe4f26f1dd6d559a1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_names</definition>
        <argsstring>()</argsstring>
        <name>ml_names</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1993" column="12" bodyfile="src/ml_list.c" bodystart="1993" bodyend="1997"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a5e126a6d8e278926855cca8f1830a6e5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_names_add</definition>
        <argsstring>(ml_value_t *Names, ml_value_t *Value)</argsstring>
        <name>ml_names_add</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Names</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="1999" column="6" bodyfile="src/ml_list.c" bodystart="1999" bodyend="2011"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1a195a01856bf23ecaf680d89f6a367c9a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(MLListT, MLNamesT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>MLListT</type>
        </param>
        <param>
          <type>MLNamesT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="2013" column="1" bodyfile="src/ml_list.c" bodystart="2013" bodyend="2017"/>
      </memberdef>
      <memberdef kind="function" id="ml__list_8c_1ae213d4f52887694661f8761a9db15306" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_list_init</definition>
        <argsstring>()</argsstring>
        <name>ml_list_init</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_list.c" line="2019" column="6" bodyfile="src/ml_list.c" bodystart="2019" bodyend="2029"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;ml_list.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;minilang.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ml_macros.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ml_sequence.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>ML_CATEGORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_CATEGORY<sp/>&quot;list&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*ml_list_index(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index)<sp/>{</highlight></codeline>
<codeline lineno="11"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="12"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>&lt;=<sp/>0)<sp/>Index<sp/>+=<sp/>Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="13"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>&gt;<sp/>Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="14"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>==<sp/>Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="15"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>&lt;<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="16"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>==<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="17"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>CachedIndex<sp/>=<sp/>List-&gt;CachedIndex;</highlight></codeline>
<codeline lineno="18"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(Index<sp/>-<sp/>CachedIndex)<sp/>{</highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>-1:<sp/>{</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>Index;</highlight></codeline>
<codeline lineno="21"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(List-&gt;CachedNode<sp/>=<sp/>List-&gt;CachedNode-&gt;Prev);</highlight></codeline>
<codeline lineno="22"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="23"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>0:<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List-&gt;CachedNode;</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/>1:<sp/>{</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>Index;</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(List-&gt;CachedNode<sp/>=<sp/>List-&gt;CachedNode-&gt;Next);</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>Index;</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node;</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(2<sp/>*<sp/>Index<sp/>&lt;<sp/>CachedIndex)<sp/>{</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Steps<sp/>=<sp/>Index<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>Node<sp/>=<sp/>Node-&gt;Next;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(--Steps);</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>&lt;<sp/>CachedIndex)<sp/>{</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;CachedNode;</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Steps<sp/>=<sp/>CachedIndex<sp/>-<sp/>Index;</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>Node<sp/>=<sp/>Node-&gt;Prev;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(--Steps);</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(2<sp/>*<sp/>Index<sp/>&lt;<sp/>CachedIndex<sp/>+<sp/>Length)<sp/>{</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;CachedNode;</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Steps<sp/>=<sp/>Index<sp/>-<sp/>CachedIndex;</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>Node<sp/>=<sp/>Node-&gt;Next;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(--Steps);</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Steps<sp/>=<sp/>Length<sp/>-<sp/>Index;</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>Node<sp/>=<sp/>Node-&gt;Prev;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(--Steps);</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(List-&gt;CachedNode<sp/>=<sp/>Node);</highlight></codeline>
<codeline lineno="49"><highlight class="normal">}</highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal">ML_TYPE(MLListT,<sp/>(MLSequenceT),<sp/></highlight><highlight class="stringliteral">&quot;list&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>list<sp/>of<sp/>elements.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal">);</highlight></codeline>
<codeline lineno="54"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_MUTABLES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal">ML_TYPE(MLListMutableT,<sp/>(MLListT),<sp/></highlight><highlight class="stringliteral">&quot;list::mutable&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="57"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MLListMutableT<sp/>MLListT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_update_generic(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Type-&gt;Type<sp/>!=<sp/>MLTypeGenericT)<sp/>{</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Type<sp/>=<sp/>ml_generic_type(2,<sp/>(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*[]){List-&gt;Type,<sp/>ml_typeof(Value)});</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*ValueType0<sp/>=<sp/>ml_typeof(Value);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*BaseType<sp/>=<sp/>ml_generic_type_args(List-&gt;Type)[0];</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*ValueType<sp/>=<sp/>ml_generic_type_args(List-&gt;Type)[1];</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_is_subtype(ValueType0,<sp/>ValueType))<sp/>{</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*ValueType2<sp/>=<sp/>ml_type_max(ValueType,<sp/>ValueType0);</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ValueType<sp/>!=<sp/>ValueType2)<sp/>{</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Type<sp/>=<sp/>ml_generic_type(2,<sp/>(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*[]){BaseType,<sp/>ValueType2});</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="77"><highlight class="normal">}</highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_value_find_all,<sp/>MLListT,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/>ml_value_find_fn<sp/>RefFn)<sp/>{</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!RefFn(Data,<sp/>Value,<sp/>1))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Value,<sp/>Iter)<sp/>ml_value_find_all(Iter-&gt;Value,<sp/>Data,<sp/>RefFn);</highlight></codeline>
<codeline lineno="84"><highlight class="normal">}</highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_node_deref(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node)<sp/>{</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="88"><highlight class="normal">}</highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_node_assign(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Value);</highlight></codeline>
<codeline lineno="93"><highlight class="normal">}</highlight></codeline>
<codeline lineno="94"><highlight class="normal"></highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_MUTABLES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"></highlight></codeline>
<codeline lineno="97"><highlight class="normal">ML_TYPE(MLListNodeT,<sp/>(),<sp/></highlight><highlight class="stringliteral">&quot;list::node&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>node<sp/>in<sp/>a<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Dereferencing<sp/>a<sp/>:mini:`list::node::const`<sp/>returns<sp/>the<sp/>corresponding<sp/>value<sp/>from<sp/>the<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/>.deref<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_node_deref</highlight></codeline>
<codeline lineno="101"><highlight class="normal">);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal">ML_TYPE(MLListNodeMutableT,<sp/>(MLListNodeT),<sp/></highlight><highlight class="stringliteral">&quot;list::node::mutable&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>node<sp/>in<sp/>a<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Dereferencing<sp/>a<sp/>:mini:`list::node`<sp/>returns<sp/>the<sp/>corresponding<sp/>value<sp/>from<sp/>the<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Assigning<sp/>to<sp/>a<sp/>:mini:`list::node`<sp/>updates<sp/>the<sp/>corresponding<sp/>value<sp/>in<sp/>the<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/>.deref<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_node_deref,</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>.assign<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_node_assign</highlight></codeline>
<codeline lineno="109"><highlight class="normal">);</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MLListNodeMutableT<sp/>MLListNodeT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal">ML_TYPE(MLListNodeMutableT,<sp/>(),<sp/></highlight><highlight class="stringliteral">&quot;list::node&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="116"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>node<sp/>in<sp/>a<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="117"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Dereferencing<sp/>a<sp/>:mini:`list::node`<sp/>returns<sp/>the<sp/>corresponding<sp/>value<sp/>from<sp/>the<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Assigning<sp/>to<sp/>a<sp/>:mini:`list::node`<sp/>updates<sp/>the<sp/>corresponding<sp/>value<sp/>in<sp/>the<sp/>:mini:`list`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>.deref<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_node_deref,</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/>.assign<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_node_assign</highlight></codeline>
<codeline lineno="121"><highlight class="normal">);</highlight></codeline>
<codeline lineno="122"><highlight class="normal"></highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_next,<sp/>MLListNodeT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node)<sp/>{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Next<sp/>=<sp/>Node-&gt;Next;</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Next)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/>Next-&gt;Index<sp/>=<sp/>Node-&gt;Index<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Next);</highlight></codeline>
<codeline lineno="130"><highlight class="normal">}</highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_key,<sp/>MLListNodeT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node)<sp/>{</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(ml_integer(Node-&gt;Index));</highlight></codeline>
<codeline lineno="134"><highlight class="normal">}</highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_value,<sp/>MLListNodeT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node)<sp/>{</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Node);</highlight></codeline>
<codeline lineno="138"><highlight class="normal">}</highlight></codeline>
<codeline lineno="139"><highlight class="normal"></highlight></codeline>
<codeline lineno="140"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list()<sp/>{</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref>);</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Type<sp/>=<sp/>MLListMutableT;</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="146"><highlight class="normal">}</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal">ML_METHOD(MLListT)<sp/>{</highlight></codeline>
<codeline lineno="149"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="150"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>an<sp/>empty<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>list()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list();</highlight></codeline>
<codeline lineno="153"><highlight class="normal">}</highlight></codeline>
<codeline lineno="154"><highlight class="normal"></highlight></codeline>
<codeline lineno="155"><highlight class="normal">ML_METHOD(MLListT,<sp/>MLTupleT)<sp/>{</highlight></codeline>
<codeline lineno="156"><highlight class="normal"></highlight><highlight class="comment">//&lt;Tuple</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>list<sp/>containing<sp/>the<sp/>values<sp/>in<sp/>:mini:`Tuple`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>list((1,<sp/>2,<sp/>3))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__tuple__t" kindref="compound">ml_tuple_t</ref><sp/>*Tuple<sp/>=<sp/>(<ref refid="structml__tuple__t" kindref="compound">ml_tuple_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Tuple-&gt;Size;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value<sp/>=<sp/>Tuple-&gt;Values[I];</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_put(List,<sp/>ml_deref(Value));</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List;</highlight></codeline>
<codeline lineno="167"><highlight class="normal">}</highlight></codeline>
<codeline lineno="168"><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>list_iterate(<ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value);</highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>list_iter_value(<ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/>Value<sp/>=<sp/>ml_deref(Value);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Value);</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_put(State-&gt;Values[0],<sp/>Value);</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)list_iterate;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_iter_next((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>State-&gt;Iter);</highlight></codeline>
<codeline lineno="177"><highlight class="normal">}</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>list_iterate(<ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Value);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)list_iter_value;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Value<sp/>==<sp/>MLNil)<sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>State-&gt;Values[0]);</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_iter_value((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>State-&gt;Iter<sp/>=<sp/>Value);</highlight></codeline>
<codeline lineno="184"><highlight class="normal">}</highlight></codeline>
<codeline lineno="185"><highlight class="normal"></highlight></codeline>
<codeline lineno="186"><highlight class="normal">ML_METHODVX(MLListT,<sp/>MLSequenceT)<sp/>{</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight><highlight class="comment">//&lt;Sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>list<sp/>of<sp/>all<sp/>of<sp/>the<sp/>values<sp/>produced<sp/>by<sp/>:mini:`Sequence`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>list(1<sp/>..<sp/>10)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref><sp/>*State<sp/>=<sp/>xnew(<ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref>,<sp/>1,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*);</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)list_iterate;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Values[0]<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_iterate((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>ml_chained(Count,<sp/>Args));</highlight></codeline>
<codeline lineno="197"><highlight class="normal">}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal">ML_METHODVX(</highlight><highlight class="stringliteral">&quot;grow&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLSequenceT)<sp/>{</highlight></codeline>
<codeline lineno="200"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight><highlight class="comment">//&lt;Sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pushes<sp/>of<sp/>all<sp/>of<sp/>the<sp/>values<sp/>produced<sp/>by<sp/>:mini:`Sequence`<sp/>onto<sp/>:mini:`List`<sp/>and<sp/>returns<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>L<sp/>:=<sp/>[1,<sp/>2,<sp/>3]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:grow(4<sp/>..<sp/>6)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref><sp/>*State<sp/>=<sp/>xnew(<ref refid="structml__iter__state__t" kindref="compound">ml_iter_state_t</ref>,<sp/>1,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*);</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)list_iterate;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Values[0]<sp/>=<sp/>Args[0];</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_iterate((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>ml_chained(Count<sp/>-<sp/>1,<sp/>Args<sp/>+<sp/>1));</highlight></codeline>
<codeline lineno="212"><highlight class="normal">}</highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_from_array(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Values,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length)<sp/>{</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Length;<sp/>++I)<sp/>ml_list_put(List,<sp/>Values[I]);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List;</highlight></codeline>
<codeline lineno="218"><highlight class="normal">}</highlight></codeline>
<codeline lineno="219"><highlight class="normal"></highlight></codeline>
<codeline lineno="220"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_to_array(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Values)<sp/>{</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List)-&gt;Head;<sp/>Node;<sp/>Node<sp/>=<sp/>Node-&gt;Next,<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Values[I]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="225"><highlight class="normal">}</highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_grow(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count)<sp/>{</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0;</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>ml_list_put(List0,<sp/>MLNil);</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="232"><highlight class="normal">}</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_push(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0;</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref>);</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Type<sp/>=<sp/>MLListNodeMutableT;</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Node-&gt;Next<sp/>=<sp/>List-&gt;Head))<sp/>{</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="244"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_update_generic(List,<sp/>Value);</highlight></codeline>
<codeline lineno="246"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>++List-&gt;Length;</highlight></codeline>
<codeline lineno="250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_put(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref>);</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Type<sp/>=<sp/>MLListNodeMutableT;</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type0<sp/>=<sp/>ml_typeof(Value);</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Type0<sp/>==<sp/>MLUninitializedT)<sp/>{</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_uninitialized_use(Value,<sp/>&amp;Node-&gt;Value);</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Type0<sp/>=<sp/>MLAnyT;</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Node-&gt;Prev<sp/>=<sp/>List-&gt;Tail))<sp/>{</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail-&gt;Next<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_update_generic(List,<sp/>Value);</highlight></codeline>
<codeline lineno="269"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>++List-&gt;Length;</highlight></codeline>
<codeline lineno="272"><highlight class="normal">}</highlight></codeline>
<codeline lineno="273"><highlight class="normal"></highlight></codeline>
<codeline lineno="274"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_pop(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0)<sp/>{</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0;</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((List-&gt;Head<sp/>=<sp/>Node-&gt;Next))<sp/>{</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--List-&gt;Length;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="290"><highlight class="normal">}</highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_pull(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0)<sp/>{</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((List-&gt;Tail<sp/>=<sp/>Node-&gt;Prev))<sp/>{</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>--List-&gt;Length;</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="307"><highlight class="normal">}</highlight></codeline>
<codeline lineno="308"><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_get(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index)<sp/>{</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>ml_list_index((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0,<sp/>Index);</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Node<sp/>?<sp/>Node-&gt;Value<sp/>:<sp/>NULL;</highlight></codeline>
<codeline lineno="312"><highlight class="normal">}</highlight></codeline>
<codeline lineno="313"><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_set(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List0,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>ml_list_index((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)List0,<sp/>Index);</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Old<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Old;</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="323"><highlight class="normal">}</highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ml_list_foreach(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>(*callback)(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*))<sp/>{</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Value,<sp/>Node)<sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(callback(Node-&gt;Value,<sp/>Data))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="328"><highlight class="normal">}</highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;precount&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="331"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"></highlight><highlight class="comment">//&gt;integer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>length<sp/>of<sp/>:mini:`List`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>[1,<sp/>2,<sp/>3]:count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_integer(List-&gt;Length);</highlight></codeline>
<codeline lineno="337"><highlight class="normal">}</highlight></codeline>
<codeline lineno="338"><highlight class="normal"></highlight></codeline>
<codeline lineno="339"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;count&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="340"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="341"><highlight class="normal"></highlight><highlight class="comment">//&gt;integer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>length<sp/>of<sp/>:mini:`List`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="343"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>[1,<sp/>2,<sp/>3]:count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_integer(List-&gt;Length);</highlight></codeline>
<codeline lineno="346"><highlight class="normal">}</highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;length&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"></highlight><highlight class="comment">//&gt;integer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>length<sp/>of<sp/>:mini:`List`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="352"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>[1,<sp/>2,<sp/>3]:length</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_integer(List-&gt;Length);</highlight></codeline>
<codeline lineno="355"><highlight class="normal">}</highlight></codeline>
<codeline lineno="356"><highlight class="normal"></highlight></codeline>
<codeline lineno="357"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;first&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>first<sp/>value<sp/>in<sp/>:mini:`List`<sp/>or<sp/>:mini:`nil`<sp/>if<sp/>:mini:`List`<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List-&gt;Head<sp/>?<sp/>List-&gt;Head-&gt;Value<sp/>:<sp/>MLNil;</highlight></codeline>
<codeline lineno="362"><highlight class="normal">}</highlight></codeline>
<codeline lineno="363"><highlight class="normal"></highlight></codeline>
<codeline lineno="364"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;last&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="365"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>last<sp/>value<sp/>in<sp/>:mini:`List`<sp/>or<sp/>:mini:`nil`<sp/>if<sp/>:mini:`List`<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List-&gt;Tail<sp/>?<sp/>List-&gt;Tail-&gt;Value<sp/>:<sp/>MLNil;</highlight></codeline>
<codeline lineno="369"><highlight class="normal">}</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371" refid="structml__list__filter__state__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Filter;</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List,<sp/>*Drop;</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node;</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>**KeepSlot;</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*KeepTail;</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>**DropSlot;</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*DropTail;</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length;</highlight></codeline>
<codeline lineno="381"><highlight class="normal">}<sp/><ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref>;</highlight></codeline>
<codeline lineno="382"><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_filter_state_run(<ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result)<sp/>{</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>{</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Head<sp/>=<sp/>State-&gt;List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Result);</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>resume;</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(State-&gt;Node)<sp/>{</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>State-&gt;Filter,<sp/>1,<sp/>&amp;State-&gt;Node-&gt;Value);</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/>resume:</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>==<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node-&gt;Prev<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropSlot[0]<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropSlot<sp/>=<sp/>&amp;State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropTail<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node-&gt;Prev<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepSlot[0]<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepSlot<sp/>=<sp/>&amp;State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++State-&gt;Length;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepTail<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;Tail<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;DropTail)<sp/>State-&gt;DropTail-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;Length<sp/>=<sp/>State-&gt;List-&gt;Length<sp/>-<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;CachedIndex<sp/>=<sp/>State-&gt;Drop-&gt;Length;</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;CachedNode<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Tail<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;KeepTail)<sp/>State-&gt;KeepTail-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Length<sp/>=<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedIndex<sp/>=<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedNode<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>State-&gt;Drop);</highlight></codeline>
<codeline lineno="420"><highlight class="normal">}</highlight></codeline>
<codeline lineno="421"><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;filter&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLFunctionT)<sp/>{</highlight></codeline>
<codeline lineno="423"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="424"><highlight class="normal"></highlight><highlight class="comment">//&lt;Filter</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="425"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>every<sp/>:mini:`Value`<sp/>from<sp/>:mini:`List`<sp/>for<sp/>which<sp/>:mini:`Function(Value)`<sp/>returns<sp/>:mini:`nil`<sp/>and<sp/>returns<sp/>those<sp/>values<sp/>in<sp/>a<sp/>new<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>L<sp/>:=<sp/>[1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:filter(2<sp/>|<sp/>_)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="429"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref>);</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="433"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_filter_state_run;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>List;</highlight></codeline>
<codeline lineno="436"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Drop<sp/>=<sp/>State-&gt;Drop<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref>);</highlight></codeline>
<codeline lineno="437"><highlight class="normal"><sp/><sp/><sp/><sp/>Drop-&gt;Type<sp/>=<sp/>MLListMutableT;</highlight></codeline>
<codeline lineno="438"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Filter<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="439"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="440"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;KeepSlot<sp/>=<sp/>&amp;List-&gt;Head;</highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;KeepTail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;DropSlot<sp/>=<sp/>&amp;Drop-&gt;Head;</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;DropTail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_filter_state_run(State,<sp/>NULL);</highlight></codeline>
<codeline lineno="447"><highlight class="normal">}</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_remove_state_run(<ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result)<sp/>{</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>{</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Head<sp/>=<sp/>State-&gt;List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Result);</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>resume;</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(State-&gt;Node)<sp/>{</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>State-&gt;Filter,<sp/>1,<sp/>&amp;State-&gt;Node-&gt;Value);</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>resume:</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>!=<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node-&gt;Prev<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropSlot[0]<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropSlot<sp/>=<sp/>&amp;State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;DropTail<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node-&gt;Prev<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepSlot[0]<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepSlot<sp/>=<sp/>&amp;State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++State-&gt;Length;</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;KeepTail<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;Tail<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;DropTail)<sp/>State-&gt;DropTail-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;Length<sp/>=<sp/>State-&gt;List-&gt;Length<sp/>-<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;CachedIndex<sp/>=<sp/>State-&gt;Drop-&gt;Length;</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Drop-&gt;CachedNode<sp/>=<sp/>State-&gt;DropTail;</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Tail<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;KeepTail)<sp/>State-&gt;KeepTail-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Length<sp/>=<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedIndex<sp/>=<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedNode<sp/>=<sp/>State-&gt;KeepTail;</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>State-&gt;Drop);</highlight></codeline>
<codeline lineno="486"><highlight class="normal">}</highlight></codeline>
<codeline lineno="487"><highlight class="normal"></highlight></codeline>
<codeline lineno="488"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;remove&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLFunctionT)<sp/>{</highlight></codeline>
<codeline lineno="489"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight><highlight class="comment">//&lt;Filter</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>every<sp/>:mini:`Value`<sp/>from<sp/>:mini:`List`<sp/>for<sp/>which<sp/>:mini:`Function(Value)`<sp/>returns<sp/>non-:mini:`nil`<sp/>and<sp/>returns<sp/>those<sp/>values<sp/>in<sp/>a<sp/>new<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>L<sp/>:=<sp/>[1,<sp/>2,<sp/>3,<sp/>4,<sp/>5,<sp/>6]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="494"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:remove(2<sp/>|<sp/>_)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="495"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__filter__state__t" kindref="compound">ml_list_filter_state_t</ref>);</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_remove_state_run;</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>List;</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Drop<sp/>=<sp/>State-&gt;Drop<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref>);</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/>Drop-&gt;Type<sp/>=<sp/>MLListMutableT;</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Filter<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;KeepSlot<sp/>=<sp/>&amp;List-&gt;Head;</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;KeepTail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;DropSlot<sp/>=<sp/>&amp;Drop-&gt;Head;</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;DropTail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_remove_state_run(State,<sp/>NULL);</highlight></codeline>
<codeline lineno="513"><highlight class="normal">}</highlight></codeline>
<codeline lineno="514"><highlight class="normal"></highlight></codeline>
<codeline lineno="515"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="516"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight><highlight class="comment">//&lt;Index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"></highlight><highlight class="comment">//&gt;list::node<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>:mini:`Index`-th<sp/>node<sp/>in<sp/>:mini:`List`<sp/>or<sp/>:mini:`nil`<sp/>if<sp/>:mini:`Index`<sp/>is<sp/>outside<sp/>the<sp/>range<sp/>of<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="520"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Indexing<sp/>starts<sp/>at<sp/>:mini:`1`.<sp/>Negative<sp/>indices<sp/>are<sp/>counted<sp/>from<sp/>the<sp/>end<sp/>of<sp/>the<sp/>list,<sp/>with<sp/>:mini:`-1`<sp/>returning<sp/>the<sp/>last<sp/>node.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="521"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>L<sp/>:=<sp/>[&quot;a&quot;,<sp/>&quot;b&quot;,<sp/>&quot;c&quot;,<sp/>&quot;d&quot;,<sp/>&quot;e&quot;,<sp/>&quot;f&quot;]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="522"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L[3]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="523"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L[-2]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="524"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L[8]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)ml_list_index(List,<sp/>Index)<sp/>?:<sp/>MLNil;</highlight></codeline>
<codeline lineno="528"><highlight class="normal">}</highlight></codeline>
<codeline lineno="529"><highlight class="normal"></highlight></codeline>
<codeline lineno="530" refid="structml__list__slice__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Head;</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length;</highlight></codeline>
<codeline lineno="534"><highlight class="normal">}<sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref>;</highlight></codeline>
<codeline lineno="535"><highlight class="normal"></highlight></codeline>
<codeline lineno="536"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_list_slice_deref(<ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice)<sp/>{</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>Slice-&gt;Head;</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>Slice-&gt;Length;</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Node<sp/>&amp;&amp;<sp/>Length)<sp/>{</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_put(List,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Node-&gt;Next;</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--Length;</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List;</highlight></codeline>
<codeline lineno="546"><highlight class="normal">}</highlight></codeline>
<codeline lineno="547"><highlight class="normal"></highlight></codeline>
<codeline lineno="548"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_slice_assign(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Packed)<sp/>{</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>Slice-&gt;Head;</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>Slice-&gt;Length;</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Node<sp/>&amp;&amp;<sp/>Length)<sp/>{</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value<sp/>=<sp/>ml_unpack(Packed,<sp/>Index<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++Index;</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Node-&gt;Next;</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--Length;</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Packed);</highlight></codeline>
<codeline lineno="560"><highlight class="normal">}</highlight></codeline>
<codeline lineno="561"><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal">ML_TYPE(MLListSliceT,<sp/>(),<sp/></highlight><highlight class="stringliteral">&quot;list-slice&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>slice<sp/>of<sp/>a<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/>.deref<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_slice_deref,</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/>.assign<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_list_slice_assign</highlight></codeline>
<codeline lineno="566"><highlight class="normal">);</highlight></codeline>
<codeline lineno="567"><highlight class="normal"></highlight></codeline>
<codeline lineno="568"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="569"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="570"><highlight class="normal"></highlight><highlight class="comment">//&lt;From</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="571"><highlight class="normal"></highlight><highlight class="comment">//&lt;To</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal"></highlight><highlight class="comment">//&gt;list::slice</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="573"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>slice<sp/>of<sp/>:mini:`List`<sp/>starting<sp/>at<sp/>:mini:`From`<sp/>(inclusive)<sp/>and<sp/>ending<sp/>at<sp/>:mini:`To`<sp/>(exclusive).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="574"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Indexing<sp/>starts<sp/>at<sp/>:mini:`1`.<sp/>Negative<sp/>indices<sp/>are<sp/>counted<sp/>from<sp/>the<sp/>end<sp/>of<sp/>the<sp/>list,<sp/>with<sp/>:mini:`-1`<sp/>returning<sp/>the<sp/>last<sp/>node.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>End<sp/>=<sp/>ml_integer_value_fast(Args[2]);</highlight></codeline>
<codeline lineno="578"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="579"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&lt;=<sp/>0)<sp/>End<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="580"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0<sp/>||<sp/>End<sp/>&lt;<sp/>Start<sp/>||<sp/>End<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="581"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref>);</highlight></codeline>
<codeline lineno="582"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Type<sp/>=<sp/>MLListSliceT;</highlight></codeline>
<codeline lineno="583"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Head<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="584"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Length<sp/>=<sp/>End<sp/>-<sp/>Start;</highlight></codeline>
<codeline lineno="585"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Slice;</highlight></codeline>
<codeline lineno="586"><highlight class="normal">}</highlight></codeline>
<codeline lineno="587"><highlight class="normal"></highlight></codeline>
<codeline lineno="588"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_MUTABLES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="589"><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLIntegerT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>End<sp/>=<sp/>ml_integer_value_fast(Args[2]);</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&lt;=<sp/>0)<sp/>End<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0<sp/>||<sp/>End<sp/>&lt;<sp/>Start<sp/>||<sp/>End<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref>);</highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Type<sp/>=<sp/>MLListSliceT;</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Head<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Length<sp/>=<sp/>End<sp/>-<sp/>Start;</highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_deref((<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Slice);</highlight></codeline>
<codeline lineno="603"><highlight class="normal">}</highlight></codeline>
<codeline lineno="604"><highlight class="normal"></highlight></codeline>
<codeline lineno="605"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="606"><highlight class="normal"></highlight></codeline>
<codeline lineno="607"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerRangeT)<sp/>{</highlight></codeline>
<codeline lineno="608"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="609"><highlight class="normal"></highlight><highlight class="comment">//&lt;Range</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight><highlight class="comment">//&gt;list::slice</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="611"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>slice<sp/>of<sp/>:mini:`List`<sp/>starting<sp/>at<sp/>:mini:`Range:start`<sp/>and<sp/>ending<sp/>at<sp/>:mini:`Range:limit`,<sp/>both<sp/>inclusive.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="612"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Indexing<sp/>starts<sp/>at<sp/>:mini:`1`.<sp/>Negative<sp/>indices<sp/>are<sp/>counted<sp/>from<sp/>the<sp/>end<sp/>of<sp/>the<sp/>list,<sp/>with<sp/>:mini:`-1`<sp/>returning<sp/>the<sp/>last<sp/>node.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__integer__range__t" kindref="compound">ml_integer_range_t</ref><sp/>*Range<sp/>=<sp/>(<ref refid="structml__integer__range__t" kindref="compound">ml_integer_range_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>Range-&gt;Start,<sp/>End<sp/>=<sp/>Range-&gt;Limit<sp/>+<sp/>1,<sp/>Step<sp/>=<sp/>Range-&gt;Step;</highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Step<sp/>!=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;ValueError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>step<sp/>size<sp/>for<sp/>list<sp/>slice&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&lt;=<sp/>0)<sp/>End<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0<sp/>||<sp/>End<sp/>&lt;<sp/>Start<sp/>||<sp/>End<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref>);</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Type<sp/>=<sp/>MLListSliceT;</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Head<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Length<sp/>=<sp/>End<sp/>-<sp/>Start;</highlight></codeline>
<codeline lineno="624"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Slice;</highlight></codeline>
<codeline lineno="625"><highlight class="normal">}</highlight></codeline>
<codeline lineno="626"><highlight class="normal"></highlight></codeline>
<codeline lineno="627"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_MUTABLES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="628"><highlight class="normal"></highlight></codeline>
<codeline lineno="629"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLIntegerRangeT)<sp/>{</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__integer__range__t" kindref="compound">ml_integer_range_t</ref><sp/>*Range<sp/>=<sp/>(<ref refid="structml__integer__range__t" kindref="compound">ml_integer_range_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>Range-&gt;Start,<sp/>End<sp/>=<sp/>Range-&gt;Limit<sp/>+<sp/>1,<sp/>Step<sp/>=<sp/>Range-&gt;Step;</highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Step<sp/>!=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;ValueError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Invalid<sp/>step<sp/>size<sp/>for<sp/>list<sp/>slice&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&lt;=<sp/>0)<sp/>End<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0<sp/>||<sp/>End<sp/>&lt;<sp/>Start<sp/>||<sp/>End<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref><sp/>*Slice<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__slice__t" kindref="compound">ml_list_slice_t</ref>);</highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Type<sp/>=<sp/>MLListSliceT;</highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Head<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="641"><highlight class="normal"><sp/><sp/><sp/><sp/>Slice-&gt;Length<sp/>=<sp/>End<sp/>-<sp/>Start;</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_deref((<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Slice);</highlight></codeline>
<codeline lineno="643"><highlight class="normal">}</highlight></codeline>
<codeline lineno="644"><highlight class="normal"></highlight></codeline>
<codeline lineno="645"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="646"><highlight class="normal"></highlight></codeline>
<codeline lineno="647"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="648"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="649"><highlight class="normal"></highlight><highlight class="comment">//&lt;Indices</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="650"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="651"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>list<sp/>containing<sp/>the<sp/>:mini:`List[Indices[1]]`,<sp/>:mini:`List[Indices[2]]`,<sp/>etc.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Args[1],<sp/>Iter)<sp/>{</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index<sp/>=<sp/>ml_integer_value(Iter-&gt;Value);</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>ml_list_index(List,<sp/>Index);</highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_put(Result,<sp/>Node<sp/>?<sp/>Node-&gt;Value<sp/>:<sp/>MLNil);</highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Result;</highlight></codeline>
<codeline lineno="660"><highlight class="normal">}</highlight></codeline>
<codeline lineno="661"><highlight class="normal"></highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*EqualMethod;</highlight></codeline>
<codeline lineno="663"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*LessMethod;</highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*GreaterMethod;</highlight></codeline>
<codeline lineno="665"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*NotEqualMethod;</highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*LessEqualMethod;</highlight></codeline>
<codeline lineno="667"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*GreaterEqualMethod;</highlight></codeline>
<codeline lineno="668"><highlight class="normal"></highlight></codeline>
<codeline lineno="669" refid="structml__list__compare__state__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result,<sp/>*Order,<sp/>*Default;</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*A,<sp/>*B;</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Args[2];</highlight></codeline>
<codeline lineno="674"><highlight class="normal">}<sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>;</highlight></codeline>
<codeline lineno="675"><highlight class="normal"></highlight></codeline>
<codeline lineno="676"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_compare_equal_run(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Base.Caller;</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>ML_RETURN(Result);</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>==<sp/>MLNil)<sp/>ML_RETURN(State-&gt;Result);</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*A<sp/>=<sp/>State-&gt;A<sp/>=<sp/>State-&gt;A-&gt;Next;</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*B<sp/>=<sp/>State-&gt;B<sp/>=<sp/>State-&gt;B-&gt;Next;</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A<sp/>||<sp/>!B)<sp/>ML_RETURN(State-&gt;Default);</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Value;</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Value;</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="686"><highlight class="normal">}</highlight></codeline>
<codeline lineno="687"><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;=&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="689"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="690"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A:size<sp/>=<sp/>B:size`<sp/>and<sp/>:mini:`A/i<sp/>=<sp/>B/i`<sp/>for<sp/>each<sp/>:mini:`i`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="694"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>=([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="696"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="697"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>=([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>!=<sp/>B-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_equal_run;</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="717"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="720"><highlight class="normal">}</highlight></codeline>
<codeline lineno="721"><highlight class="normal"></highlight></codeline>
<codeline lineno="722"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;!=&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="723"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="724"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="725"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="726"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A:size<sp/>!=<sp/>B:size`<sp/>or<sp/>:mini:`A/i<sp/>!=<sp/>B/i`<sp/>for<sp/>some<sp/>:mini:`i`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="727"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>!=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="728"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>!=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="729"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>!=([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="730"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>!=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="731"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>!=([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>!=<sp/>B-&gt;Length)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="742"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_equal_run;</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="754"><highlight class="normal">}</highlight></codeline>
<codeline lineno="755"><highlight class="normal"></highlight></codeline>
<codeline lineno="756"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_compare_order_run(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result);</highlight></codeline>
<codeline lineno="757"><highlight class="normal"></highlight></codeline>
<codeline lineno="758"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_compare_order2_run(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Base.Caller;</highlight></codeline>
<codeline lineno="760"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>ML_RETURN(Result);</highlight></codeline>
<codeline lineno="761"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>==<sp/>MLNil)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="762"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*A<sp/>=<sp/>State-&gt;A<sp/>=<sp/>State-&gt;A-&gt;Next;</highlight></codeline>
<codeline lineno="763"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*B<sp/>=<sp/>State-&gt;B<sp/>=<sp/>State-&gt;B-&gt;Next;</highlight></codeline>
<codeline lineno="764"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A<sp/>||<sp/>!B)<sp/>ML_RETURN(State-&gt;Default);</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Value;</highlight></codeline>
<codeline lineno="766"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Value;</highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order_run;</highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Order,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="769"><highlight class="normal">}</highlight></codeline>
<codeline lineno="770"><highlight class="normal"></highlight></codeline>
<codeline lineno="771"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_compare_order_run(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Base.Caller;</highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>ML_RETURN(Result);</highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>!=<sp/>MLNil)<sp/>ML_RETURN(State-&gt;Result);</highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>State-&gt;A-&gt;Value;</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>State-&gt;B-&gt;Value;</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order2_run;</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="779"><highlight class="normal">}</highlight></codeline>
<codeline lineno="780"><highlight class="normal"></highlight></codeline>
<codeline lineno="781"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;&lt;&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="785"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A/i<sp/>=<sp/>B/i`<sp/>for<sp/>each<sp/>:mini:`i<sp/>=<sp/>1<sp/>..<sp/>j-1`<sp/>and<sp/>:mini:`A/j<sp/>&lt;<sp/>B/j`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="786"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="787"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="788"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="789"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="800"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="801"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="803"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order_run;</highlight></codeline>
<codeline lineno="807"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="809"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Order<sp/>=<sp/>LessMethod;</highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>&gt;=<sp/>B-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="812"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="815"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="817"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="818"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="819"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="820"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>LessMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="821"><highlight class="normal">}</highlight></codeline>
<codeline lineno="822"><highlight class="normal"></highlight></codeline>
<codeline lineno="823"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;&lt;=&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="824"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="825"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="826"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="827"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A/i<sp/>=<sp/>B/i`<sp/>for<sp/>each<sp/>:mini:`i<sp/>=<sp/>1<sp/>..<sp/>j-1`<sp/>and<sp/>:mini:`A/j<sp/>&lt;=<sp/>B/j`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="830"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;=([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="832"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&lt;=([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="834"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="843"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="845"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="846"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="847"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="848"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order_run;</highlight></codeline>
<codeline lineno="849"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="850"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="851"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="852"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Order<sp/>=<sp/>LessMethod;</highlight></codeline>
<codeline lineno="853"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>&gt;<sp/>B-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="854"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="857"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="859"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="860"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="861"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="862"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>LessMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="863"><highlight class="normal">}</highlight></codeline>
<codeline lineno="864"><highlight class="normal"></highlight></codeline>
<codeline lineno="865"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;&gt;&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="866"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="867"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="868"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="869"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A/i<sp/>=<sp/>B/i`<sp/>for<sp/>each<sp/>:mini:`i<sp/>=<sp/>1<sp/>..<sp/>j-1`<sp/>and<sp/>:mini:`A/j<sp/>&gt;<sp/>B/j`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="871"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="873"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="874"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="875"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="876"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="877"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="878"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="879"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="880"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="881"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="882"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="885"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(A);</highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="887"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="889"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="890"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order_run;</highlight></codeline>
<codeline lineno="891"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="892"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="893"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="894"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Order<sp/>=<sp/>GreaterMethod;</highlight></codeline>
<codeline lineno="895"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>&lt;=<sp/>B-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="896"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="897"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="898"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="899"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="900"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="901"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="902"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="903"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>GreaterMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="905"><highlight class="normal">}</highlight></codeline>
<codeline lineno="906"><highlight class="normal"></highlight></codeline>
<codeline lineno="907"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;&gt;=&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="908"><highlight class="normal"></highlight><highlight class="comment">//&lt;A</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="909"><highlight class="normal"></highlight><highlight class="comment">//&lt;B</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="910"><highlight class="normal"></highlight><highlight class="comment">//&gt;B<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>:mini:`B`<sp/>if<sp/>:mini:`A/i<sp/>=<sp/>B/i`<sp/>for<sp/>each<sp/>:mini:`i<sp/>=<sp/>1<sp/>..<sp/>j-1`<sp/>and<sp/>:mini:`A/j<sp/>&gt;=<sp/>B/j`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="912"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="913"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="914"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;=([1,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="915"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;=([1,<sp/>2,<sp/>3],<sp/>[1,<sp/>2,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="916"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>&gt;=([1,<sp/>3,<sp/>2],<sp/>[1,<sp/>2,<sp/>3])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="917"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*A<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*B<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>Caller;<sp/>State<sp/>&amp;&amp;<sp/>State-&gt;Type<sp/>==<sp/>MLComparisonStateT;<sp/>State<sp/>=<sp/>State-&gt;Caller)<sp/>{</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*Previous<sp/>=<sp/>(<ref refid="structml__comparison__state__t" kindref="compound">ml_comparison_state_t</ref><sp/>*)State;</highlight></codeline>
<codeline lineno="921"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Previous-&gt;A<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A<sp/>&amp;&amp;<sp/>Previous-&gt;B<sp/>==<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!A-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="925"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="927"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!B-&gt;Length)<sp/>ML_RETURN(B);</highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__compare__state__t" kindref="compound">ml_list_compare_state_t</ref>);</highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Type<sp/>=<sp/>MLComparisonStateT;</highlight></codeline>
<codeline lineno="930"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Base.run<sp/>=<sp/>(ml_state_fn)ml_list_compare_order_run;</highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.A<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)A;</highlight></codeline>
<codeline lineno="934"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.B<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Order<sp/>=<sp/>GreaterMethod;</highlight></codeline>
<codeline lineno="937"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(A-&gt;Length<sp/>&lt;<sp/>B-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Default<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)B;</highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;A<sp/>=<sp/>A-&gt;Head;</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;B<sp/>=<sp/>B-&gt;Head;</highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>A-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="945"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>B-&gt;Head-&gt;Value;</highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>GreaterMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="947"><highlight class="normal">}</highlight></codeline>
<codeline lineno="948"><highlight class="normal"></highlight></codeline>
<codeline lineno="949"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;append&quot;</highlight><highlight class="normal">,<sp/>MLStringBufferT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="950"><highlight class="normal"></highlight><highlight class="comment">//&lt;Buffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="951"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Appends<sp/>a<sp/>representation<sp/>of<sp/>:mini:`List`<sp/>to<sp/>:mini:`Buffer`<sp/>of<sp/>the<sp/>form<sp/>:mini:`&quot;[&quot;<sp/>+<sp/>repr(V/1)<sp/>+<sp/>&quot;,<sp/>&quot;<sp/>+<sp/>repr(V/2)<sp/>+<sp/>&quot;,<sp/>&quot;<sp/>+<sp/>...<sp/>+<sp/>repr(V/n)<sp/>+<sp/>&quot;]&quot;`,<sp/>where<sp/>:mini:`repr(V/i)`<sp/>is<sp/>a<sp/>representation<sp/>of<sp/>the<sp/>*i*-th<sp/>element<sp/>(using<sp/>:mini:`:append`).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="953"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>B<sp/>:=<sp/>string::buffer()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="954"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>B:append([1,<sp/>2,<sp/>3,<sp/>4])</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="955"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>B:rest</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="956"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*Buffer<sp/>=<sp/>(<ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="957"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_put(Buffer,<sp/></highlight><highlight class="charliteral">&apos;[&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="958"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="959"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="960"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="961"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_simple_append(Buffer,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="962"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Node<sp/>=<sp/>Node-&gt;Next))<sp/>{</highlight></codeline>
<codeline lineno="963"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_write(Buffer,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">,<sp/>2);</highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_simple_append(Buffer,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="965"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="967"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_put(Buffer,<sp/></highlight><highlight class="charliteral">&apos;]&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="968"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Buffer;</highlight></codeline>
<codeline lineno="969"><highlight class="normal">}</highlight></codeline>
<codeline lineno="970"><highlight class="normal"></highlight></codeline>
<codeline lineno="971"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;append&quot;</highlight><highlight class="normal">,<sp/>MLStringBufferT,<sp/>MLListT,<sp/>MLStringT)<sp/>{</highlight></codeline>
<codeline lineno="972"><highlight class="normal"></highlight><highlight class="comment">//&lt;Buffer</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="973"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="974"><highlight class="normal"></highlight><highlight class="comment">//&lt;Sep</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="975"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Appends<sp/>a<sp/>representation<sp/>of<sp/>:mini:`List`<sp/>to<sp/>:mini:`Buffer`<sp/>of<sp/>the<sp/>form<sp/>:mini:`repr(V/1)<sp/>+<sp/>Sep<sp/>+<sp/>repr(V/2)<sp/>+<sp/>Sep<sp/>+<sp/>...<sp/>+<sp/>repr(V/n)`,<sp/>where<sp/>:mini:`repr(V/i)`<sp/>is<sp/>a<sp/>representation<sp/>of<sp/>the<sp/>*i*-th<sp/>element<sp/>(using<sp/>:mini:`:append`).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="976"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>let<sp/>B<sp/>:=<sp/>string::buffer()</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="977"><highlight class="normal"></highlight><highlight class="comment">//$-<sp/>B:append([1,<sp/>2,<sp/>3,<sp/>4],<sp/>&quot;<sp/>-<sp/>&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="978"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>B:rest</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="979"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*Buffer<sp/>=<sp/>(<ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="980"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Seperator<sp/>=<sp/>ml_string_value(Args[2]);</highlight></codeline>
<codeline lineno="981"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>SeperatorLength<sp/>=<sp/>ml_string_length(Args[2]);</highlight></codeline>
<codeline lineno="982"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="983"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="984"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="985"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_simple_append(Buffer,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="986"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Node<sp/>=<sp/>Node-&gt;Next))<sp/>{</highlight></codeline>
<codeline lineno="987"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_write(Buffer,<sp/>Seperator,<sp/>SeperatorLength);</highlight></codeline>
<codeline lineno="988"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_stringbuffer_simple_append(Buffer,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="989"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="990"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Buffer;</highlight></codeline>
<codeline lineno="992"><highlight class="normal">}</highlight></codeline>
<codeline lineno="993"><highlight class="normal"></highlight></codeline>
<codeline lineno="994"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ML_TYPED_FN(ml_unpack,<sp/>MLListT,<sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index)<sp/>{</highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)ml_list_index(List,<sp/>Index)<sp/>?:<sp/>MLNil;</highlight></codeline>
<codeline lineno="996"><highlight class="normal">}</highlight></codeline>
<codeline lineno="997"><highlight class="normal"></highlight></codeline>
<codeline lineno="998"><highlight class="normal"></highlight><highlight class="comment">/*typedef<sp/>struct<sp/>ml_list_iterator_t<sp/>{</highlight></codeline>
<codeline lineno="999"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_type_t<sp/>*Type;</highlight></codeline>
<codeline lineno="1000"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_list_node_t<sp/>*Node;</highlight></codeline>
<codeline lineno="1001"><highlight class="comment"><sp/><sp/><sp/><sp/>long<sp/>Index;</highlight></codeline>
<codeline lineno="1002"><highlight class="comment">}<sp/>ml_list_iterator_t;</highlight></codeline>
<codeline lineno="1003"><highlight class="comment"></highlight></codeline>
<codeline lineno="1004"><highlight class="comment">static<sp/>void<sp/>ML_TYPED_FN(ml_iter_value,<sp/>MLListIterT,<sp/>ml_state_t<sp/>*Caller,<sp/>ml_list_iterator_t<sp/>*Iter)<sp/>{</highlight></codeline>
<codeline lineno="1005"><highlight class="comment"><sp/><sp/><sp/><sp/>ML_RETURN(Iter-&gt;Node);</highlight></codeline>
<codeline lineno="1006"><highlight class="comment">}</highlight></codeline>
<codeline lineno="1007"><highlight class="comment"></highlight></codeline>
<codeline lineno="1008"><highlight class="comment">static<sp/>void<sp/>ML_TYPED_FN(ml_iter_next,<sp/>MLListIterT,<sp/>ml_state_t<sp/>*Caller,<sp/>ml_list_iterator_t<sp/>*Iter)<sp/>{</highlight></codeline>
<codeline lineno="1009"><highlight class="comment"><sp/><sp/><sp/><sp/>if<sp/>((Iter-&gt;Node<sp/>=<sp/>Iter-&gt;Node-&gt;Next))<sp/>{</highlight></codeline>
<codeline lineno="1010"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++Iter-&gt;Index;</highlight></codeline>
<codeline lineno="1011"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(Iter);</highlight></codeline>
<codeline lineno="1012"><highlight class="comment"><sp/><sp/><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline lineno="1013"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1014"><highlight class="comment"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1015"><highlight class="comment">}</highlight></codeline>
<codeline lineno="1016"><highlight class="comment"></highlight></codeline>
<codeline lineno="1017"><highlight class="comment">static<sp/>void<sp/>ML_TYPED_FN(ml_iter_key,<sp/>MLListIterT,<sp/>ml_state_t<sp/>*Caller,<sp/>ml_list_iterator_t<sp/>*Iter)<sp/>{</highlight></codeline>
<codeline lineno="1018"><highlight class="comment"><sp/><sp/><sp/><sp/>ML_RETURN(ml_integer(Iter-&gt;Index));</highlight></codeline>
<codeline lineno="1019"><highlight class="comment">}</highlight></codeline>
<codeline lineno="1020"><highlight class="comment"></highlight></codeline>
<codeline lineno="1021"><highlight class="comment">ML_TYPE(MLListIterT,<sp/>(),<sp/>&quot;list-iterator&quot;);</highlight></codeline>
<codeline lineno="1023"><highlight class="normal">*/</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"></highlight></codeline>
<codeline lineno="1025"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iterate,<sp/>MLListT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List)<sp/>{</highlight></codeline>
<codeline lineno="1026"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head-&gt;Index<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(List-&gt;Head);</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1032"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1033"><highlight class="normal"></highlight></codeline>
<codeline lineno="1034" refid="structml__list__skip__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List;</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count;</highlight></codeline>
<codeline lineno="1038"><highlight class="normal">}<sp/><ref refid="structml__list__skip__t" kindref="compound">ml_list_skip_t</ref>;</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"></highlight></codeline>
<codeline lineno="1040"><highlight class="normal">ML_TYPE(MLListSkipT,<sp/>(MLSequenceT),<sp/></highlight><highlight class="stringliteral">&quot;list::skip&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"></highlight></codeline>
<codeline lineno="1042"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iterate,<sp/>MLListSkipT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__list__skip__t" kindref="compound">ml_list_skip_t</ref><sp/>*Skip)<sp/>{</highlight></codeline>
<codeline lineno="1043"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Skip-&gt;Count<sp/>&lt;<sp/>0)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1044"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Skip-&gt;Count<sp/>&gt;=<sp/>Skip-&gt;List-&gt;Length)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>ml_list_index(Skip-&gt;List,<sp/>Skip-&gt;Count<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Index<sp/>=<sp/>Skip-&gt;Count<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Node);</highlight></codeline>
<codeline lineno="1048"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1049"><highlight class="normal"></highlight></codeline>
<codeline lineno="1050"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;skip&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__skip__t" kindref="compound">ml_list_skip_t</ref><sp/>*Skip<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__skip__t" kindref="compound">ml_list_skip_t</ref>);</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"><sp/><sp/><sp/><sp/>Skip-&gt;Type<sp/>=<sp/>MLListSkipT;</highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/>Skip-&gt;List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/>Skip-&gt;Count<sp/>=<sp/>ml_integer_value(Args[1]);</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Skip;</highlight></codeline>
<codeline lineno="1057"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1058"><highlight class="normal"></highlight></codeline>
<codeline lineno="1059"><highlight class="normal">ML_METHODV(</highlight><highlight class="stringliteral">&quot;push&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1060"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1061"><highlight class="normal"></highlight><highlight class="comment">//&lt;Values...:<sp/>any</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1062"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1063"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pushes<sp/>:mini:`Values`<sp/>onto<sp/>the<sp/>start<sp/>of<sp/>:mini:`List`<sp/>and<sp/>returns<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1064"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>Args[0];</highlight></codeline>
<codeline lineno="1065"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>ml_list_push(List,<sp/>Args[I]);</highlight></codeline>
<codeline lineno="1066"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Args[0];</highlight></codeline>
<codeline lineno="1067"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1068"><highlight class="normal"></highlight></codeline>
<codeline lineno="1069"><highlight class="normal">ML_METHODV(</highlight><highlight class="stringliteral">&quot;put&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1070"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1071"><highlight class="normal"></highlight><highlight class="comment">//&lt;Values...:<sp/>any</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1072"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1073"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Pushes<sp/>:mini:`Values`<sp/>onto<sp/>the<sp/>end<sp/>of<sp/>:mini:`List`<sp/>and<sp/>returns<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>Args[0];</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>ml_list_put(List,<sp/>Args[I]);</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Args[0];</highlight></codeline>
<codeline lineno="1077"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1078"><highlight class="normal"></highlight></codeline>
<codeline lineno="1079"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;pop&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1080"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1081"><highlight class="normal"></highlight><highlight class="comment">//&gt;any<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1082"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>and<sp/>returns<sp/>the<sp/>first<sp/>element<sp/>of<sp/>:mini:`List`<sp/>or<sp/>:mini:`nil`<sp/>if<sp/>the<sp/>:mini:`List`<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1083"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_pop(Args[0])<sp/>?:<sp/>MLNil;</highlight></codeline>
<codeline lineno="1084"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"></highlight></codeline>
<codeline lineno="1086"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;pull&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1088"><highlight class="normal"></highlight><highlight class="comment">//&gt;any<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1089"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>and<sp/>returns<sp/>the<sp/>last<sp/>element<sp/>of<sp/>:mini:`List`<sp/>or<sp/>:mini:`nil`<sp/>if<sp/>the<sp/>:mini:`List`<sp/>is<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1090"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_pull(Args[0])<sp/>?:<sp/>MLNil;</highlight></codeline>
<codeline lineno="1091"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1092"><highlight class="normal"></highlight></codeline>
<codeline lineno="1093"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;empty&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1094"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1095"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1096"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>all<sp/>elements<sp/>from<sp/>:mini:`List`<sp/>and<sp/>returns<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1097"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1098"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1100"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1101"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Type<sp/>=<sp/>MLListMutableT;</highlight></codeline>
<codeline lineno="1102"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1104"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1105"><highlight class="normal"></highlight></codeline>
<codeline lineno="1106"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;+&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="1107"><highlight class="normal"></highlight><highlight class="comment">//&lt;List/1</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1108"><highlight class="normal"></highlight><highlight class="comment">//&lt;List/2</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1109"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1110"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>list<sp/>with<sp/>the<sp/>elements<sp/>of<sp/>:mini:`List/1`<sp/>followed<sp/>by<sp/>the<sp/>elements<sp/>of<sp/>:mini:`List/2`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1111"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Args[0],<sp/>Iter)<sp/>ml_list_put(List,<sp/>Iter-&gt;Value);</highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Args[1],<sp/>Iter)<sp/>ml_list_put(List,<sp/>Iter-&gt;Value);</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List;</highlight></codeline>
<codeline lineno="1115"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1116"><highlight class="normal"></highlight></codeline>
<codeline lineno="1117"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;splice&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1118"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1119"><highlight class="normal"></highlight><highlight class="comment">//&gt;list<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1120"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>all<sp/>elements<sp/>from<sp/>:mini:`List`.<sp/>Returns<sp/>the<sp/>removed<sp/>elements<sp/>as<sp/>a<sp/>new<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Removed<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)ml_list();</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/>*Removed<sp/>=<sp/>*List;</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Removed;</highlight></codeline>
<codeline lineno="1127"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1128"><highlight class="normal"></highlight></codeline>
<codeline lineno="1129"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;splice&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="1130"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1131"><highlight class="normal"></highlight><highlight class="comment">//&lt;Index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1132"><highlight class="normal"></highlight><highlight class="comment">//&lt;Count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1133"><highlight class="normal"></highlight><highlight class="comment">//&gt;list<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1134"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>:mini:`Count`<sp/>elements<sp/>from<sp/>:mini:`List`<sp/>starting<sp/>at<sp/>:mini:`Index`.<sp/>Returns<sp/>the<sp/>removed<sp/>elements<sp/>as<sp/>a<sp/>new<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1135"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1139"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Remove<sp/>=<sp/>ml_integer_value_fast(Args[2]);</highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Remove<sp/>&lt;<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1141"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Removed<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)ml_list();</highlight></codeline>
<codeline lineno="1142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Remove<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1144"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>End<sp/>=<sp/>Start<sp/>+<sp/>Remove<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&gt;<sp/>List-&gt;Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>==<sp/>List-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*Removed<sp/>=<sp/>*List;</highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*EndNode<sp/>=<sp/>ml_list_index(List,<sp/>End);</highlight></codeline>
<codeline lineno="1154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*NextNode<sp/>=<sp/>EndNode-&gt;Next;</highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EndNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>EndNode;</highlight></codeline>
<codeline lineno="1158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1164"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*StartNode<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="1167"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*PrevNode<sp/>=<sp/>StartNode-&gt;Prev;</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StartNode-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>==<sp/>List-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1170"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="1172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*EndNode<sp/>=<sp/>ml_list_index(List,<sp/>End);</highlight></codeline>
<codeline lineno="1180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*NextNode<sp/>=<sp/>EndNode-&gt;Next;</highlight></codeline>
<codeline lineno="1181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EndNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>EndNode;</highlight></codeline>
<codeline lineno="1184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1192"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Removed;</highlight></codeline>
<codeline lineno="1194"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1195"><highlight class="normal"></highlight></codeline>
<codeline lineno="1196"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;splice&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerT,<sp/>MLIntegerT,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1197"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1198"><highlight class="normal"></highlight><highlight class="comment">//&lt;Index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1199"><highlight class="normal"></highlight><highlight class="comment">//&lt;Count</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1200"><highlight class="normal"></highlight><highlight class="comment">//&lt;Source</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1201"><highlight class="normal"></highlight><highlight class="comment">//&gt;list<sp/>|<sp/>nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1202"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>:mini:`Count`<sp/>elements<sp/>from<sp/>:mini:`List`<sp/>starting<sp/>at<sp/>:mini:`Index`,<sp/>then<sp/>inserts<sp/>the<sp/>elements<sp/>from<sp/>:mini:`Source`,<sp/>leaving<sp/>:mini:`Source`<sp/>empty.<sp/>Returns<sp/>the<sp/>removed<sp/>elements<sp/>as<sp/>a<sp/>new<sp/>list.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Remove<sp/>=<sp/>ml_integer_value_fast(Args[2]);</highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Remove<sp/>&lt;<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Source<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[3];</highlight></codeline>
<codeline lineno="1210"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Removed<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)ml_list();</highlight></codeline>
<codeline lineno="1211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Remove<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="1212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Source-&gt;Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Removed;</highlight></codeline>
<codeline lineno="1214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1216"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Head)<sp/>{</highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Tail)<sp/>{</highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*StartNode<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="1232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*PrevNode<sp/>=<sp/>StartNode-&gt;Prev;</highlight></codeline>
<codeline lineno="1233"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1234"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1235"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StartNode-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>End<sp/>=<sp/>Start<sp/>+<sp/>Remove<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>&gt;<sp/>List-&gt;Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>==<sp/>List-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*Removed<sp/>=<sp/>*List;</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*List<sp/>=<sp/>*Source;</highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*EndNode<sp/>=<sp/>ml_list_index(List,<sp/>End);</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*NextNode<sp/>=<sp/>EndNode-&gt;Next;</highlight></codeline>
<codeline lineno="1250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EndNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>EndNode;</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Source-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1265"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*StartNode<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="1268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*PrevNode<sp/>=<sp/>StartNode-&gt;Prev;</highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StartNode-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(End<sp/>==<sp/>List-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="1273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Source-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*EndNode<sp/>=<sp/>ml_list_index(List,<sp/>End);</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*NextNode<sp/>=<sp/>EndNode-&gt;Next;</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>EndNode-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;CachedNode<sp/>=<sp/>Removed-&gt;Head<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Tail<sp/>=<sp/>EndNode;</highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Removed-&gt;Length<sp/>=<sp/>Remove;</highlight></codeline>
<codeline lineno="1292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Source-&gt;Length)<sp/>{</highlight></codeline>
<codeline lineno="1293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1294"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1295"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NextNode-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>NextNode;</highlight></codeline>
<codeline lineno="1300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>-=<sp/>Remove;</highlight></codeline>
<codeline lineno="1304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1306"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>+=<sp/>Source-&gt;Length;</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"><sp/><sp/><sp/><sp/>Source-&gt;Head<sp/>=<sp/>Source-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/>Source-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1310"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Removed;</highlight></codeline>
<codeline lineno="1311"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"></highlight></codeline>
<codeline lineno="1313"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;splice&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerT,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1315"><highlight class="normal"></highlight><highlight class="comment">//&lt;Index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1316"><highlight class="normal"></highlight><highlight class="comment">//&lt;Source</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1317"><highlight class="normal"></highlight><highlight class="comment">//&gt;nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1318"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Inserts<sp/>the<sp/>elements<sp/>from<sp/>:mini:`Source`<sp/>into<sp/>:mini:`List`<sp/>starting<sp/>at<sp/>:mini:`Index`,<sp/>leaving<sp/>:mini:`Source`<sp/>empty.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1319"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Start<sp/>=<sp/>ml_integer_value_fast(Args[1]);</highlight></codeline>
<codeline lineno="1321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/>Start<sp/>+=<sp/>List-&gt;Length<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="1322"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&lt;=<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1323"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*Source<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[2];</highlight></codeline>
<codeline lineno="1324"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>&gt;<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1325"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Source-&gt;Length)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Head)<sp/>{</highlight></codeline>
<codeline lineno="1329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1334"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Start<sp/>==<sp/>List-&gt;Length<sp/>+<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>List-&gt;Tail;</highlight></codeline>
<codeline lineno="1336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(List-&gt;Tail)<sp/>{</highlight></codeline>
<codeline lineno="1337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*StartNode<sp/>=<sp/>ml_list_index(List,<sp/>Start);</highlight></codeline>
<codeline lineno="1344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*PrevNode<sp/>=<sp/>StartNode-&gt;Prev;</highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PrevNode-&gt;Next<sp/>=<sp/>Source-&gt;Head;</highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Head-&gt;Prev<sp/>=<sp/>PrevNode;</highlight></codeline>
<codeline lineno="1347"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StartNode-&gt;Prev<sp/>=<sp/>Source-&gt;Tail;</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Source-&gt;Tail-&gt;Next<sp/>=<sp/>StartNode;</highlight></codeline>
<codeline lineno="1349"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1350"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1351"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>+=<sp/>Source-&gt;Length;</highlight></codeline>
<codeline lineno="1353"><highlight class="normal"><sp/><sp/><sp/><sp/>Source-&gt;Head<sp/>=<sp/>Source-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1354"><highlight class="normal"><sp/><sp/><sp/><sp/>Source-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1355"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1356"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"></highlight></codeline>
<codeline lineno="1358"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;reverse&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1359"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1360"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1361"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Reverses<sp/>:mini:`List`<sp/>in-place<sp/>and<sp/>returns<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Prev<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1364"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Prev)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Prev;</highlight></codeline>
<codeline lineno="1366"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>Prev-&gt;Next;</highlight></codeline>
<codeline lineno="1367"><highlight class="normal"><sp/><sp/><sp/><sp/>Prev-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1368"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Next<sp/>=<sp/>Node-&gt;Next;</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Prev;</highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Prev-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1374"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/>Prev-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Prev;</highlight></codeline>
<codeline lineno="1377"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>Prev;</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1380"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1381"><highlight class="normal"></highlight></codeline>
<codeline lineno="1382" refid="structml__list__sort__state__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1383"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="1384"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List;</highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Compare;</highlight></codeline>
<codeline lineno="1386"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Args[2];</highlight></codeline>
<codeline lineno="1387"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Head,<sp/>*Tail;</highlight></codeline>
<codeline lineno="1388"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*P,<sp/>*Q;</highlight></codeline>
<codeline lineno="1389"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length;</highlight></codeline>
<codeline lineno="1390"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>InSize,<sp/>NMerges;</highlight></codeline>
<codeline lineno="1391"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>PSize,<sp/>QSize;</highlight></codeline>
<codeline lineno="1392"><highlight class="normal">}<sp/><ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref>;</highlight></codeline>
<codeline lineno="1393"><highlight class="normal"></highlight></codeline>
<codeline lineno="1394"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_sort_state_run(<ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="1395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>resume;</highlight></codeline>
<codeline lineno="1396"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;;)<sp/>{</highlight></codeline>
<codeline lineno="1397"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;P<sp/>=<sp/>State-&gt;Head;</highlight></codeline>
<codeline lineno="1398"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail<sp/>=<sp/>State-&gt;Head<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1399"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;NMerges<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(State-&gt;P)<sp/>{</highlight></codeline>
<codeline lineno="1401"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;NMerges++;</highlight></codeline>
<codeline lineno="1402"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Q<sp/>=<sp/>State-&gt;P;</highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;PSize<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>State-&gt;InSize;<sp/>I++)<sp/>{</highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;PSize++;</highlight></codeline>
<codeline lineno="1406"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Q<sp/>=<sp/>State-&gt;Q-&gt;Next;</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!State-&gt;Q)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1408"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1409"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;QSize<sp/>=<sp/>State-&gt;InSize;</highlight></codeline>
<codeline lineno="1410"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(State-&gt;PSize<sp/>&gt;<sp/>0<sp/>||<sp/>(State-&gt;QSize<sp/>&gt;<sp/>0<sp/>&amp;&amp;<sp/>State-&gt;Q))<sp/>{</highlight></codeline>
<codeline lineno="1411"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*E;</highlight></codeline>
<codeline lineno="1412"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;PSize<sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="1413"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>State-&gt;Q;<sp/>State-&gt;Q<sp/>=<sp/>State-&gt;Q-&gt;Next;<sp/>State-&gt;QSize--;</highlight></codeline>
<codeline lineno="1414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;QSize<sp/>==<sp/>0<sp/>||<sp/>!State-&gt;Q)<sp/>{</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>State-&gt;P;<sp/>State-&gt;P<sp/>=<sp/>State-&gt;P-&gt;Next;<sp/>State-&gt;PSize--;</highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>State-&gt;P-&gt;Value;</highlight></codeline>
<codeline lineno="1418"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>State-&gt;Q-&gt;Value;</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call((<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*)State,<sp/>State-&gt;Compare,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>resume:</highlight></codeline>
<codeline lineno="1421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Result))<sp/>{</highlight></codeline>
<codeline lineno="1422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;P,<sp/>*Next;</highlight></codeline>
<codeline lineno="1423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;Tail)<sp/>{</highlight></codeline>
<codeline lineno="1424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail-&gt;Next<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Head<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Prev<sp/>=<sp/>State-&gt;Tail;</highlight></codeline>
<codeline lineno="1429"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Size<sp/>=<sp/>State-&gt;PSize;<sp/>--Size<sp/>&gt;<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="1430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Next<sp/>=<sp/>Node-&gt;Next;<sp/>Next-&gt;Prev<sp/>=<sp/>Node;<sp/>Node<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1432"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Next<sp/>=<sp/>State-&gt;Q;</highlight></codeline>
<codeline lineno="1433"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1434"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Next-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1435"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1436"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Node-&gt;Next)<sp/>{</highlight></codeline>
<codeline lineno="1437"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Next<sp/>=<sp/>Node-&gt;Next;<sp/>Next-&gt;Prev<sp/>=<sp/>Node;<sp/>Node<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1438"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1439"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1440"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1441"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>finished;</highlight></codeline>
<codeline lineno="1442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Result<sp/>==<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="1443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>State-&gt;Q;<sp/>State-&gt;Q<sp/>=<sp/>State-&gt;Q-&gt;Next;<sp/>State-&gt;QSize--;</highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E<sp/>=<sp/>State-&gt;P;<sp/>State-&gt;P<sp/>=<sp/>State-&gt;P-&gt;Next;<sp/>State-&gt;PSize--;</highlight></codeline>
<codeline lineno="1446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1448"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;Tail)<sp/>{</highlight></codeline>
<codeline lineno="1449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail-&gt;Next<sp/>=<sp/>E;</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1451"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Head<sp/>=<sp/>E;</highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1453"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>E-&gt;Prev<sp/>=<sp/>State-&gt;Tail;</highlight></codeline>
<codeline lineno="1454"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail<sp/>=<sp/>E;</highlight></codeline>
<codeline lineno="1455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;P<sp/>=<sp/>State-&gt;Q;</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Tail-&gt;Next<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;NMerges<sp/>&lt;=<sp/>1)<sp/>{</highlight></codeline>
<codeline lineno="1460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Result<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)State-&gt;List;</highlight></codeline>
<codeline lineno="1461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>finished;</highlight></codeline>
<codeline lineno="1462"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;InSize<sp/>*=<sp/>2;</highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1465"><highlight class="normal">finished:</highlight></codeline>
<codeline lineno="1466"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Head<sp/>=<sp/>State-&gt;Head;</highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Tail<sp/>=<sp/>State-&gt;Tail;</highlight></codeline>
<codeline lineno="1468"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;CachedNode<sp/>=<sp/>State-&gt;Head;</highlight></codeline>
<codeline lineno="1470"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List-&gt;Length<sp/>=<sp/>State-&gt;Length;</highlight></codeline>
<codeline lineno="1471"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Result);</highlight></codeline>
<codeline lineno="1472"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1473"><highlight class="normal"></highlight></codeline>
<codeline lineno="1474"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*LessMethod;</highlight></codeline>
<codeline lineno="1475"><highlight class="normal"></highlight></codeline>
<codeline lineno="1476"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;sort&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1477"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1478"><highlight class="normal"></highlight><highlight class="comment">//&gt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1479"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Sorts<sp/>:mini:`List`<sp/>in-place<sp/>using<sp/>:mini:`&lt;`<sp/>and<sp/>returns<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_list_length(Args[0]))<sp/>ML_RETURN(Args[0]);</highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref>);</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_sort_state_run;</highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>List;</highlight></codeline>
<codeline lineno="1487"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Compare<sp/>=<sp/>LessMethod;</highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Head<sp/>=<sp/>State-&gt;List-&gt;Head;</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Length<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;InSize<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Improve<sp/>ml_list_sort_state_run<sp/>so<sp/>that<sp/>List<sp/>is<sp/>still<sp/>valid<sp/>during<sp/>sort</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1492"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1493"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1494"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_sort_state_run(State,<sp/>NULL);</highlight></codeline>
<codeline lineno="1496"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1497"><highlight class="normal"></highlight></codeline>
<codeline lineno="1498"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;sort&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLFunctionT)<sp/>{</highlight></codeline>
<codeline lineno="1499"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1500"><highlight class="normal"></highlight><highlight class="comment">//&lt;Compare</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1501"><highlight class="normal"></highlight><highlight class="comment">//&gt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1502"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Sorts<sp/>:mini:`List`<sp/>in-place<sp/>using<sp/>:mini:`Compare`<sp/>and<sp/>returns<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_list_length(Args[0]))<sp/>ML_RETURN(Args[0]);</highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__sort__state__t" kindref="compound">ml_list_sort_state_t</ref>);</highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1507"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_sort_state_run;</highlight></codeline>
<codeline lineno="1508"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1509"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>List;</highlight></codeline>
<codeline lineno="1510"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Compare<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="1511"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Head<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1512"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Length<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1513"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;InSize<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Improve<sp/>ml_list_sort_state_run<sp/>so<sp/>that<sp/>List<sp/>is<sp/>still<sp/>valid<sp/>during<sp/>sort</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1515"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_list_sort_state_run(State,<sp/>NULL);</highlight></codeline>
<codeline lineno="1519"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"></highlight></codeline>
<codeline lineno="1521" refid="structml__list__find__state__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1522"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="1523"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node;</highlight></codeline>
<codeline lineno="1524"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Args[2];</highlight></codeline>
<codeline lineno="1525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index;</highlight></codeline>
<codeline lineno="1526"><highlight class="normal">}<sp/><ref refid="structml__list__find__state__t" kindref="compound">ml_list_find_state_t</ref>;</highlight></codeline>
<codeline lineno="1527"><highlight class="normal"></highlight></codeline>
<codeline lineno="1528"><highlight class="normal"></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*EqualMethod;</highlight></codeline>
<codeline lineno="1529"><highlight class="normal"></highlight></codeline>
<codeline lineno="1530"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_find_state_run(<ref refid="structml__list__find__state__t" kindref="compound">ml_list_find_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1531"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Caller;</highlight></codeline>
<codeline lineno="1532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_RETURN(Caller);</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Value<sp/>!=<sp/>MLNil)<sp/>ML_RETURN(ml_integer(State-&gt;Index));</highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="1535"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1536"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1537"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1538"><highlight class="normal"><sp/><sp/><sp/><sp/>++State-&gt;Index;</highlight></codeline>
<codeline lineno="1539"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1540"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"></highlight></codeline>
<codeline lineno="1542"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;find&quot;</highlight><highlight class="normal">,<sp/>MLListT,<sp/>MLAnyT)<sp/>{</highlight></codeline>
<codeline lineno="1543"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1544"><highlight class="normal"></highlight><highlight class="comment">//&lt;Value</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1545"><highlight class="normal"></highlight><highlight class="comment">//&gt;integer|nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1546"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>first<sp/>position<sp/>where<sp/>:mini:`List[Position]<sp/>=<sp/>Value`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0])-&gt;Head;</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__find__state__t" kindref="compound">ml_list_find_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__find__state__t" kindref="compound">ml_list_find_state_t</ref>);</highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1551"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1552"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_find_state_run;</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1555"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[1]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1556"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Index<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1557"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>EqualMethod,<sp/>2,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1558"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1559"><highlight class="normal"></highlight></codeline>
<codeline lineno="1560"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_delete(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List,<sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node)<sp/>{</highlight></codeline>
<codeline lineno="1561"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Prev<sp/>=<sp/>Node-&gt;Prev;</highlight></codeline>
<codeline lineno="1562"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Next<sp/>=<sp/>Node-&gt;Next;</highlight></codeline>
<codeline lineno="1563"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Prev)<sp/>Prev-&gt;Next<sp/>=<sp/>Next;<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>List-&gt;Head<sp/>=<sp/>Next;</highlight></codeline>
<codeline lineno="1564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Next)<sp/>Next-&gt;Prev<sp/>=<sp/>Prev;<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>List-&gt;Tail<sp/>=<sp/>Prev;</highlight></codeline>
<codeline lineno="1565"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"><sp/><sp/><sp/><sp/>--List-&gt;Length;</highlight></codeline>
<codeline lineno="1568"><highlight class="normal"><sp/><sp/><sp/><sp/>--Node-&gt;Index;</highlight></codeline>
<codeline lineno="1569"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1570"><highlight class="normal"></highlight></codeline>
<codeline lineno="1571"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;delete&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLIntegerT)<sp/>{</highlight></codeline>
<codeline lineno="1572"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight><highlight class="comment">//&lt;Index</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1574"><highlight class="normal"></highlight><highlight class="comment">//&gt;any|nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1575"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>and<sp/>returns<sp/>the<sp/>:mini:`Index`-th<sp/>value<sp/>from<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1576"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>let<sp/>L<sp/>:=<sp/>list(&quot;cake&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1577"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:delete(2)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1578"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:delete(-1)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1579"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1580"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1581"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index<sp/>=<sp/>ml_integer_value(Args[1]);</highlight></codeline>
<codeline lineno="1582"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>ml_list_index(List,<sp/>Index);</highlight></codeline>
<codeline lineno="1583"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Node)<sp/>{</highlight></codeline>
<codeline lineno="1584"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_delete(List,<sp/>Node);</highlight></codeline>
<codeline lineno="1585"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1586"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1587"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1588"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1589"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1590"><highlight class="normal"></highlight></codeline>
<codeline lineno="1591" refid="structml__list__remove__state__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1592"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="1593"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List;</highlight></codeline>
<codeline lineno="1594"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node;</highlight></codeline>
<codeline lineno="1595"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Fn;</highlight></codeline>
<codeline lineno="1596"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Args[1];</highlight></codeline>
<codeline lineno="1597"><highlight class="normal">}<sp/><ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref>;</highlight></codeline>
<codeline lineno="1598"><highlight class="normal"></highlight></codeline>
<codeline lineno="1599"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_pop_state_run(<ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Value);</highlight></codeline>
<codeline lineno="1601"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="1602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Value<sp/>!=<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="1603"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_delete(State-&gt;List,<sp/>Node);</highlight></codeline>
<codeline lineno="1604"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="1605"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1606"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Node<sp/>=<sp/>Node-&gt;Next))<sp/>{</highlight></codeline>
<codeline lineno="1607"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1608"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1609"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Fn,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1610"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1611"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>MLNil);</highlight></codeline>
<codeline lineno="1612"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1613"><highlight class="normal"></highlight></codeline>
<codeline lineno="1614"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;pop&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLFunctionT)<sp/>{</highlight></codeline>
<codeline lineno="1615"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1616"><highlight class="normal"></highlight><highlight class="comment">//&lt;Fn</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1617"><highlight class="normal"></highlight><highlight class="comment">//&gt;any|nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1618"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>and<sp/>returns<sp/>the<sp/>first<sp/>value<sp/>where<sp/>:mini:`Fn(Value)`<sp/>is<sp/>not<sp/>:mini:`nil`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1619"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>let<sp/>L<sp/>:=<sp/>list(1<sp/>..<sp/>10)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1620"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:pop(3<sp/>|<sp/>_)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1621"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1622"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0])-&gt;Head;</highlight></codeline>
<codeline lineno="1623"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1624"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref>);</highlight></codeline>
<codeline lineno="1625"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1626"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1627"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_pop_state_run;</highlight></codeline>
<codeline lineno="1628"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Fn<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="1629"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1630"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1631"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1632"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Fn,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1633"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1634"><highlight class="normal"></highlight></codeline>
<codeline lineno="1635"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_pull_state_run(<ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1636"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Value);</highlight></codeline>
<codeline lineno="1637"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node;</highlight></codeline>
<codeline lineno="1638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Value<sp/>!=<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="1639"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_delete(State-&gt;List,<sp/>Node);</highlight></codeline>
<codeline lineno="1640"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>Node-&gt;Value);</highlight></codeline>
<codeline lineno="1641"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Node<sp/>=<sp/>Node-&gt;Prev))<sp/>{</highlight></codeline>
<codeline lineno="1643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1645"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Fn,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1646"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1647"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CONTINUE(State-&gt;Base.Caller,<sp/>MLNil);</highlight></codeline>
<codeline lineno="1648"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1649"><highlight class="normal"></highlight></codeline>
<codeline lineno="1650"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;pull&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT,<sp/>MLFunctionT)<sp/>{</highlight></codeline>
<codeline lineno="1651"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1652"><highlight class="normal"></highlight><highlight class="comment">//&lt;Fn</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1653"><highlight class="normal"></highlight><highlight class="comment">//&gt;any|nil</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1654"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Removes<sp/>and<sp/>returns<sp/>the<sp/>last<sp/>value<sp/>where<sp/>:mini:`Fn(Value)`<sp/>is<sp/>not<sp/>:mini:`nil`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1655"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>let<sp/>L<sp/>:=<sp/>list(1<sp/>..<sp/>10)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1656"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:pull(3<sp/>|<sp/>_)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1657"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1658"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0])-&gt;Tail;</highlight></codeline>
<codeline lineno="1659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1660"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__remove__state__t" kindref="compound">ml_list_remove_state_t</ref>);</highlight></codeline>
<codeline lineno="1661"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1662"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1663"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_pull_state_run;</highlight></codeline>
<codeline lineno="1664"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Fn<sp/>=<sp/>Args[1];</highlight></codeline>
<codeline lineno="1665"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1666"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1667"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Fn,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1669"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1670"><highlight class="normal"></highlight></codeline>
<codeline lineno="1671"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;permute&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1673"><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1674"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1675"><highlight class="normal"></highlight><highlight class="comment">//<sp/>..<sp/>deprecated::<sp/>2.7.0</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1676"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1677"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>Use<sp/>:mini:`List:shuffle`<sp/>instead.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1678"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1679"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Permutes<sp/>:mini:`List`<sp/>in<sp/>place.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1680"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1681"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1682"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(N<sp/>&lt;=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1683"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Nodes[N],<sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1684"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I,<sp/>Node<sp/>=<sp/>Node-&gt;Next)<sp/>Nodes[I]<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1685"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>N;<sp/>--I<sp/>&gt;<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="1686"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Divisor<sp/>=<sp/>RAND_MAX<sp/>/<sp/>(I<sp/>+<sp/>1),<sp/>J;</highlight></codeline>
<codeline lineno="1687"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>J<sp/>=<sp/>random()<sp/>/<sp/>Divisor;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(J<sp/>&gt;<sp/>I);</highlight></codeline>
<codeline lineno="1688"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(J<sp/>!=<sp/>I)<sp/>{</highlight></codeline>
<codeline lineno="1689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Old<sp/>=<sp/>Nodes[J];</highlight></codeline>
<codeline lineno="1690"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[J]<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1691"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]<sp/>=<sp/>Old;</highlight></codeline>
<codeline lineno="1692"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1693"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1694"><highlight class="normal"><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Head<sp/>=<sp/>Nodes[0];</highlight></codeline>
<codeline lineno="1695"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1696"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1697"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1698"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="1699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1700"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1701"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1702"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1703"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1704"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1705"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1706"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1707"><highlight class="normal"></highlight></codeline>
<codeline lineno="1708"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;shuffle&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1710"><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1711"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1712"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Shuffles<sp/>:mini:`List`<sp/>in<sp/>place.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1713"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1714"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1715"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(N<sp/>&lt;=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1716"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Nodes[N],<sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1717"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I,<sp/>Node<sp/>=<sp/>Node-&gt;Next)<sp/>Nodes[I]<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>N;<sp/>--I<sp/>&gt;<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="1719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Divisor<sp/>=<sp/>RAND_MAX<sp/>/<sp/>(I<sp/>+<sp/>1),<sp/>J;</highlight></codeline>
<codeline lineno="1720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>J<sp/>=<sp/>random()<sp/>/<sp/>Divisor;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(J<sp/>&gt;<sp/>I);</highlight></codeline>
<codeline lineno="1721"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(J<sp/>!=<sp/>I)<sp/>{</highlight></codeline>
<codeline lineno="1722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Old<sp/>=<sp/>Nodes[J];</highlight></codeline>
<codeline lineno="1723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[J]<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]<sp/>=<sp/>Old;</highlight></codeline>
<codeline lineno="1725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1726"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1727"><highlight class="normal"><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Head<sp/>=<sp/>Nodes[0];</highlight></codeline>
<codeline lineno="1728"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1729"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1730"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1731"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="1732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1735"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1736"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1737"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1739"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1740"><highlight class="normal"></highlight></codeline>
<codeline lineno="1741"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;cycle&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1743"><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1744"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1745"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Permutes<sp/>:mini:`List`<sp/>in<sp/>place<sp/>with<sp/>no<sp/>sub-cycles.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1746"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1747"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(N<sp/>&lt;=<sp/>1)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1749"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Nodes[N],<sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1750"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I,<sp/>Node<sp/>=<sp/>Node-&gt;Next)<sp/>Nodes[I]<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1751"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>N;<sp/>--I<sp/>&gt;<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="1752"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Divisor<sp/>=<sp/>RAND_MAX<sp/>/<sp/>I,<sp/>J;</highlight></codeline>
<codeline lineno="1753"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>J<sp/>=<sp/>random()<sp/>/<sp/>Divisor;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(J<sp/>&gt;=<sp/>I);</highlight></codeline>
<codeline lineno="1754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Old<sp/>=<sp/>Nodes[J];</highlight></codeline>
<codeline lineno="1755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[J]<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]<sp/>=<sp/>Old;</highlight></codeline>
<codeline lineno="1757"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1758"><highlight class="normal"><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Head<sp/>=<sp/>Nodes[0];</highlight></codeline>
<codeline lineno="1759"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1760"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1761"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1762"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="1763"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1764"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1765"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1766"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1767"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1768"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)List;</highlight></codeline>
<codeline lineno="1770"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1771"><highlight class="normal"></highlight></codeline>
<codeline lineno="1772" refid="structml__permutations__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1773"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="1774"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List;</highlight></codeline>
<codeline lineno="1775"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>**Nodes;</highlight></codeline>
<codeline lineno="1776"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index,<sp/>Length;</highlight></codeline>
<codeline lineno="1777"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>P[];</highlight></codeline>
<codeline lineno="1778"><highlight class="normal">}<sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref>;</highlight></codeline>
<codeline lineno="1779"><highlight class="normal"></highlight></codeline>
<codeline lineno="1780"><highlight class="normal">ML_TYPE(MLPermutationsT,<sp/>(MLSequenceT),<sp/></highlight><highlight class="stringliteral">&quot;list::permutations&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1782"><highlight class="normal"></highlight></codeline>
<codeline lineno="1783"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iterate,<sp/>MLPermutationsT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref><sp/>*Permutations)<sp/>{</highlight></codeline>
<codeline lineno="1784"><highlight class="normal"><sp/><sp/><sp/><sp/>Permutations-&gt;Index<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1785"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Permutations);</highlight></codeline>
<codeline lineno="1786"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1787"><highlight class="normal"></highlight></codeline>
<codeline lineno="1788"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_next,<sp/>MLPermutationsT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref><sp/>*Permutations)<sp/>{</highlight></codeline>
<codeline lineno="1789"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>Permutations-&gt;Length;</highlight></codeline>
<codeline lineno="1790"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*P<sp/>=<sp/>Permutations-&gt;P;</highlight></codeline>
<codeline lineno="1791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Index<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1792"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(!P[Index])<sp/>{</highlight></codeline>
<codeline lineno="1793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P[Index]<sp/>=<sp/>Index;</highlight></codeline>
<codeline lineno="1794"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>++Index;</highlight></codeline>
<codeline lineno="1795"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1796"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Index<sp/>==<sp/>N)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1797"><highlight class="normal"><sp/><sp/><sp/><sp/>--P[Index];</highlight></codeline>
<codeline lineno="1798"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>J<sp/>=<sp/>Index<sp/>%<sp/>2<sp/>?<sp/>P[Index]<sp/>:<sp/>0;</highlight></codeline>
<codeline lineno="1799"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>**Nodes<sp/>=<sp/>Permutations-&gt;Nodes;</highlight></codeline>
<codeline lineno="1800"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>Nodes[Index];</highlight></codeline>
<codeline lineno="1801"><highlight class="normal"><sp/><sp/><sp/><sp/>Nodes[Index]<sp/>=<sp/>Nodes[J];</highlight></codeline>
<codeline lineno="1802"><highlight class="normal"><sp/><sp/><sp/><sp/>Nodes[J]<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1803"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>Permutations-&gt;List;</highlight></codeline>
<codeline lineno="1804"><highlight class="normal"><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>List-&gt;Head<sp/>=<sp/>Nodes[0];</highlight></codeline>
<codeline lineno="1805"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1806"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="1807"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Prev<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1808"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="1809"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]-&gt;Prev<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node<sp/>=<sp/>Nodes[I];</highlight></codeline>
<codeline lineno="1812"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1813"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Next<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1814"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1815"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;Length<sp/>=<sp/>N;</highlight></codeline>
<codeline lineno="1816"><highlight class="normal"><sp/><sp/><sp/><sp/>++Permutations-&gt;Index;</highlight></codeline>
<codeline lineno="1817"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Permutations);</highlight></codeline>
<codeline lineno="1818"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1819"><highlight class="normal"></highlight></codeline>
<codeline lineno="1820"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_key,<sp/>MLPermutationsT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref><sp/>*Permutations)<sp/>{</highlight></codeline>
<codeline lineno="1821"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(ml_integer(Permutations-&gt;Index));</highlight></codeline>
<codeline lineno="1822"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1823"><highlight class="normal"></highlight></codeline>
<codeline lineno="1824"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_iter_value,<sp/>MLPermutationsT,<sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref><sp/>*Permutations)<sp/>{</highlight></codeline>
<codeline lineno="1825"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Permutations-&gt;List);</highlight></codeline>
<codeline lineno="1826"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1827"><highlight class="normal"></highlight></codeline>
<codeline lineno="1828"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;permutations&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1829"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1830"><highlight class="normal"></highlight><highlight class="comment">//&gt;sequence</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1831"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>sequence<sp/>of<sp/>all<sp/>permutations<sp/>of<sp/>:mini:`List`,<sp/>performed<sp/>in-place.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1832"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1833"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1834"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref><sp/>*Permutations<sp/>=<sp/>xnew(<ref refid="structml__permutations__t" kindref="compound">ml_permutations_t</ref>,<sp/>N<sp/>+<sp/>1,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1835"><highlight class="normal"><sp/><sp/><sp/><sp/>Permutations-&gt;Type<sp/>=<sp/>MLPermutationsT;</highlight></codeline>
<codeline lineno="1836"><highlight class="normal"><sp/><sp/><sp/><sp/>Permutations-&gt;Length<sp/>=<sp/>N;</highlight></codeline>
<codeline lineno="1837"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>**Nodes<sp/>=<sp/>Permutations-&gt;Nodes<sp/>=<sp/>anew(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*,<sp/>N);</highlight></codeline>
<codeline lineno="1838"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>List-&gt;Head;</highlight></codeline>
<codeline lineno="1839"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>N;<sp/>++I,<sp/>Node<sp/>=<sp/>Node-&gt;Next)<sp/>{</highlight></codeline>
<codeline lineno="1840"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Nodes[I]<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Permutations-&gt;P[I]<sp/>=<sp/>I;</highlight></codeline>
<codeline lineno="1842"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1843"><highlight class="normal"><sp/><sp/><sp/><sp/>Permutations-&gt;P[N]<sp/>=<sp/>N;</highlight></codeline>
<codeline lineno="1844"><highlight class="normal"><sp/><sp/><sp/><sp/>Permutations-&gt;List<sp/>=<sp/>List;</highlight></codeline>
<codeline lineno="1845"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Permutations;</highlight></codeline>
<codeline lineno="1846"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1847"><highlight class="normal"></highlight></codeline>
<codeline lineno="1848"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;random&quot;</highlight><highlight class="normal">,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="1849"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1850"><highlight class="normal"></highlight><highlight class="comment">//&gt;any</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1851"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>random<sp/>(assignable)<sp/>node<sp/>from<sp/>:mini:`List`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1852"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>let<sp/>L<sp/>:=<sp/>list(&quot;cake&quot;)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1853"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:random</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1854"><highlight class="normal"></highlight><highlight class="comment">//$=<sp/>L:random</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1855"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1856"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Limit<sp/>=<sp/>List-&gt;Length;</highlight></codeline>
<codeline lineno="1857"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Limit<sp/>&lt;=<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLNil;</highlight></codeline>
<codeline lineno="1858"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Divisor<sp/>=<sp/>RAND_MAX<sp/>/<sp/>Limit;</highlight></codeline>
<codeline lineno="1859"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Random;</highlight></codeline>
<codeline lineno="1860"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>Random<sp/>=<sp/>random()<sp/>/<sp/>Divisor;<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Random<sp/>&gt;=<sp/>Limit);</highlight></codeline>
<codeline lineno="1861"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)ml_list_index(List,<sp/>Random<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="1862"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1863"><highlight class="normal"></highlight></codeline>
<codeline lineno="1864" refid="structml__list__visit__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1865"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>Base;</highlight></codeline>
<codeline lineno="1866"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Visitor,<sp/>*Dest;</highlight></codeline>
<codeline lineno="1867"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node;</highlight></codeline>
<codeline lineno="1868"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Args[1];</highlight></codeline>
<codeline lineno="1869"><highlight class="normal">}<sp/><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref>;</highlight></codeline>
<codeline lineno="1870"><highlight class="normal"></highlight></codeline>
<codeline lineno="1871"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_visit_run(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1872"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Caller;</highlight></codeline>
<codeline lineno="1873"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_RETURN(Value);</highlight></codeline>
<codeline lineno="1874"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="1875"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1876"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1877"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1878"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1879"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1880"><highlight class="normal"></highlight></codeline>
<codeline lineno="1881"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;visit&quot;</highlight><highlight class="normal">,<sp/>MLVisitorT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="1882"><highlight class="normal"></highlight><highlight class="comment">//&lt;Visitor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1883"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1884"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1885"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>list<sp/>containing<sp/>copies<sp/>of<sp/>the<sp/>elements<sp/>of<sp/>:mini:`List`<sp/>created<sp/>using<sp/>:mini:`Copy`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1886"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*Visitor<sp/>=<sp/>(<ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1887"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1])-&gt;Head;</highlight></codeline>
<codeline lineno="1888"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(MLNil);</highlight></codeline>
<codeline lineno="1889"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref>);</highlight></codeline>
<codeline lineno="1890"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1891"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1892"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_visit_run;</highlight></codeline>
<codeline lineno="1893"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Visitor<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor;</highlight></codeline>
<codeline lineno="1894"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1895"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1896"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1897"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1898"><highlight class="normal"></highlight></codeline>
<codeline lineno="1899"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_copy_run(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1900"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Caller;</highlight></codeline>
<codeline lineno="1901"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_RETURN(Value);</highlight></codeline>
<codeline lineno="1902"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_put(State-&gt;Dest,<sp/>Value);</highlight></codeline>
<codeline lineno="1903"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="1904"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(State-&gt;Dest);</highlight></codeline>
<codeline lineno="1905"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1906"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1907"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1908"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1909"><highlight class="normal"></highlight></codeline>
<codeline lineno="1910"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;copy&quot;</highlight><highlight class="normal">,<sp/>MLVisitorT,<sp/>MLListT)<sp/>{</highlight></codeline>
<codeline lineno="1911"><highlight class="normal"></highlight><highlight class="comment">//&lt;Visitor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1912"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1913"><highlight class="normal"></highlight><highlight class="comment">//&gt;list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1914"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>list<sp/>containing<sp/>copies<sp/>of<sp/>the<sp/>elements<sp/>of<sp/>:mini:`List`<sp/>created<sp/>using<sp/>:mini:`Copy`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1915"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*Visitor<sp/>=<sp/>(<ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1916"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Dest<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="1917"><highlight class="normal"><sp/><sp/><sp/><sp/>inthash_insert(Visitor-&gt;Cache,<sp/>(uintptr_t)Args[1],<sp/>Dest);</highlight></codeline>
<codeline lineno="1918"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1])-&gt;Head;</highlight></codeline>
<codeline lineno="1919"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(Dest);</highlight></codeline>
<codeline lineno="1920"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref>);</highlight></codeline>
<codeline lineno="1921"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1922"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1923"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_copy_run;</highlight></codeline>
<codeline lineno="1924"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Visitor<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor;</highlight></codeline>
<codeline lineno="1925"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Dest<sp/>=<sp/>Dest;</highlight></codeline>
<codeline lineno="1926"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1927"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1928"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1929"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1930"><highlight class="normal"></highlight></codeline>
<codeline lineno="1931"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_const_run(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="1932"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller<sp/>=<sp/>State-&gt;Base.Caller;</highlight></codeline>
<codeline lineno="1933"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is_error(Value))<sp/>ML_RETURN(Value);</highlight></codeline>
<codeline lineno="1934"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_put(State-&gt;Dest,<sp/>Value);</highlight></codeline>
<codeline lineno="1935"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>State-&gt;Node-&gt;Next;</highlight></codeline>
<codeline lineno="1936"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>{</highlight></codeline>
<codeline lineno="1937"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1938"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(State-&gt;Dest-&gt;Type-&gt;Type<sp/>==<sp/>MLTypeGenericT)<sp/>{</highlight></codeline>
<codeline lineno="1939"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*TArgs[2];</highlight></codeline>
<codeline lineno="1940"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_find_generic_parent(State-&gt;Dest-&gt;Type,<sp/>MLListMutableT,<sp/>2,<sp/>TArgs);</highlight></codeline>
<codeline lineno="1941"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>TArgs[0]<sp/>=<sp/>MLListT;</highlight></codeline>
<codeline lineno="1942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Dest-&gt;Type<sp/>=<sp/>ml_generic_type(2,<sp/>TArgs);</highlight></codeline>
<codeline lineno="1943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="1944"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1945"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>State-&gt;Dest-&gt;Type<sp/>=<sp/>MLListT;</highlight></codeline>
<codeline lineno="1946"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1947"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1948"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(State-&gt;Dest,<sp/>Iter)<sp/>Iter-&gt;Type<sp/>=<sp/>MLListNodeT;</highlight></codeline>
<codeline lineno="1950"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_RETURN(State-&gt;Dest);</highlight></codeline>
<codeline lineno="1951"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1952"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1953"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1954"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>State-&gt;Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1955"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1956"><highlight class="normal"></highlight></codeline>
<codeline lineno="1957"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;const&quot;</highlight><highlight class="normal">,<sp/>MLVisitorT,<sp/>MLListMutableT)<sp/>{</highlight></codeline>
<codeline lineno="1958"><highlight class="normal"></highlight><highlight class="comment">//&lt;Visitor</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1959"><highlight class="normal"></highlight><highlight class="comment">//&lt;List</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1960"><highlight class="normal"></highlight><highlight class="comment">//&gt;list::const</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1961"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>constant<sp/>list<sp/>containing<sp/>copies<sp/>of<sp/>the<sp/>elements<sp/>of<sp/>:mini:`List`<sp/>created<sp/>using<sp/>:mini:`Copy`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1962"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*Visitor<sp/>=<sp/>(<ref refid="structml__visitor__t" kindref="compound">ml_visitor_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="1963"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Dest<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="1964"><highlight class="normal"><sp/><sp/><sp/><sp/>inthash_insert(Visitor-&gt;Cache,<sp/>(uintptr_t)Args[1],<sp/>Dest);</highlight></codeline>
<codeline lineno="1965"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/>((<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Args[1])-&gt;Head;</highlight></codeline>
<codeline lineno="1966"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node)<sp/>ML_RETURN(Dest);</highlight></codeline>
<codeline lineno="1967"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref><sp/>*State<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__visit__t" kindref="compound">ml_list_visit_t</ref>);</highlight></codeline>
<codeline lineno="1968"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Caller<sp/>=<sp/>Caller;</highlight></codeline>
<codeline lineno="1969"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.Context<sp/>=<sp/>Caller-&gt;Context;</highlight></codeline>
<codeline lineno="1970"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Base.run<sp/>=<sp/>(ml_state_fn)ml_list_const_run;</highlight></codeline>
<codeline lineno="1971"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Visitor<sp/>=<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor;</highlight></codeline>
<codeline lineno="1972"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Dest<sp/>=<sp/>Dest;</highlight></codeline>
<codeline lineno="1973"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Node<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="1974"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Args[0]<sp/>=<sp/>Node-&gt;Value;</highlight></codeline>
<codeline lineno="1975"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Visitor,<sp/>1,<sp/>State-&gt;Args);</highlight></codeline>
<codeline lineno="1976"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1977"><highlight class="normal"></highlight></codeline>
<codeline lineno="1978"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_value_is_constant,<sp/>MLListMutableT,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List)<sp/>{</highlight></codeline>
<codeline lineno="1979"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="1980"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1981"><highlight class="normal"></highlight></codeline>
<codeline lineno="1982"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_value_is_constant,<sp/>MLListT,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List)<sp/>{</highlight></codeline>
<codeline lineno="1983"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(List,<sp/>Iter)<sp/>{</highlight></codeline>
<codeline lineno="1984"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_value_is_constant(Iter-&gt;Value))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="1985"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1986"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="1987"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1988"><highlight class="normal"></highlight></codeline>
<codeline lineno="1989"><highlight class="normal">ML_TYPE(MLNamesT,<sp/>(),<sp/></highlight><highlight class="stringliteral">&quot;names&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="1991"><highlight class="normal">);</highlight></codeline>
<codeline lineno="1992"><highlight class="normal"></highlight></codeline>
<codeline lineno="1993"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_names()<sp/>{</highlight></codeline>
<codeline lineno="1994"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Names<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="1995"><highlight class="normal"><sp/><sp/><sp/><sp/>Names-&gt;Type<sp/>=<sp/>MLNamesT;</highlight></codeline>
<codeline lineno="1996"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Names;</highlight></codeline>
<codeline lineno="1997"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1998"><highlight class="normal"></highlight></codeline>
<codeline lineno="1999"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_names_add(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Names,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="2000"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*List<sp/>=<sp/>(<ref refid="structml__list__t" kindref="compound">ml_list_t</ref><sp/>*)Names;</highlight></codeline>
<codeline lineno="2001"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref><sp/>*Node<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__list__node__t" kindref="compound">ml_list_node_t</ref>);</highlight></codeline>
<codeline lineno="2002"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Type<sp/>=<sp/>MLListNodeT;</highlight></codeline>
<codeline lineno="2003"><highlight class="normal"><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="2004"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>((Node-&gt;Prev<sp/>=<sp/>List-&gt;Tail))<sp/>{</highlight></codeline>
<codeline lineno="2005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Tail-&gt;Next<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="2006"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="2007"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>List-&gt;Head<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="2008"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="2009"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedNode<sp/>=<sp/>List-&gt;Tail<sp/>=<sp/>Node;</highlight></codeline>
<codeline lineno="2010"><highlight class="normal"><sp/><sp/><sp/><sp/>List-&gt;CachedIndex<sp/>=<sp/>++List-&gt;Length;</highlight></codeline>
<codeline lineno="2011"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2012"><highlight class="normal"></highlight></codeline>
<codeline lineno="2013"><highlight class="normal">ML_METHOD(MLListT,<sp/>MLNamesT)<sp/>{</highlight></codeline>
<codeline lineno="2014"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*List<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="2015"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_NAMES_FOREACH(Args[0],<sp/>Iter)<sp/>ml_list_put(List,<sp/>Iter-&gt;Value);</highlight></codeline>
<codeline lineno="2016"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>List;</highlight></codeline>
<codeline lineno="2017"><highlight class="normal">}</highlight></codeline>
<codeline lineno="2018"><highlight class="normal"></highlight></codeline>
<codeline lineno="2019"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_list_init()<sp/>{</highlight></codeline>
<codeline lineno="2020"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ml_list_init.c&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2021"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLListT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;mutable&quot;</highlight><highlight class="normal">,<sp/>MLListMutableT);</highlight></codeline>
<codeline lineno="2022"><highlight class="normal"><sp/><sp/><sp/><sp/>MLListMutableT-&gt;Constructor<sp/>=<sp/>MLListT-&gt;Constructor;</highlight></codeline>
<codeline lineno="2023"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_GENERICS</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2024"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_type_add_rule(MLListT,<sp/>MLSequenceT,<sp/>MLIntegerT,<sp/>ML_TYPE_ARG(1),<sp/>NULL);</highlight></codeline>
<codeline lineno="2025"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_MUTABLES</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2026"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_type_add_rule(MLListMutableT,<sp/>MLListT,<sp/>ML_TYPE_ARG(1),<sp/>NULL);</highlight></codeline>
<codeline lineno="2027"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2028"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2029"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="src/ml_list.c"/>
  </compounddef>
</doxygen>
