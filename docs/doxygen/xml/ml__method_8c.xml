<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.10.0" xml:lang="en-US">
  <compounddef id="ml__method_8c" kind="file" language="C++">
    <compoundname>ml_method.c</compoundname>
    <includes refid="ml__method_8h" local="yes">ml_method.h</includes>
    <includes refid="minilang_8h" local="yes">minilang.h</includes>
    <includes refid="ml__macros_8h" local="yes">ml_macros.h</includes>
    <includes local="no">string.h</includes>
    <includes local="yes">ml_method_init.c</includes>
    <incdepgraph>
      <node id="14">
        <label>inthash.h</label>
        <link refid="inthash_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="3">
        <label>minilang.h</label>
        <link refid="minilang_8h_source"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>ml_compiler.h</label>
        <link refid="ml__compiler_8h_source"/>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>ml_macros.h</label>
        <link refid="ml__macros_8h_source"/>
        <childnode refid="19" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>src/ml_method.c</label>
        <link refid="ml__method_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>ml_method.h</label>
        <link refid="ml__method_8h_source"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>ml_runtime.h</label>
        <link refid="ml__runtime_8h_source"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="9">
        <label>ml_types.h</label>
        <link refid="ml__types_8h_source"/>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>stringmap.h</label>
        <link refid="stringmap_8h_source"/>
      </node>
      <node id="19">
        <label>gc/gc.h</label>
      </node>
      <node id="17">
        <label>limits.h</label>
      </node>
      <node id="16">
        <label>ml_config.h</label>
      </node>
      <node id="20">
        <label>ml_method_init.c</label>
      </node>
      <node id="7">
        <label>setjmp.h</label>
      </node>
      <node id="12">
        <label>stdarg.h</label>
      </node>
      <node id="15">
        <label>stdint.h</label>
      </node>
      <node id="10">
        <label>stdio.h</label>
      </node>
      <node id="4">
        <label>stdlib.h</label>
      </node>
      <node id="11">
        <label>string.h</label>
      </node>
      <node id="5">
        <label>unistd.h</label>
      </node>
    </incdepgraph>
    <innerclass refid="structml__method__definition__t" prot="public">ml_method_definition_t</innerclass>
    <innerclass refid="structml__methods__t" prot="public">ml_methods_t</innerclass>
    <innerclass refid="structml__method__switch__t" prot="public">ml_method_switch_t</innerclass>
    <innerclass refid="structml__method__instance__t" prot="public">ml_method_instance_t</innerclass>
    <sectiondef kind="define">
      <memberdef kind="define" id="ml__method_8c_1aebec330325aff5cbc7d9c9248e2cae4a" prot="public" static="no">
        <name>ML_CATEGORY</name>
        <initializer>&quot;method&quot;</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="11" column="10" bodyfile="src/ml_method.c" bodystart="11" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ml__method_8c_1a8d90ba7b9eb886bf51284ca61a7b6f91" prot="public" static="no">
        <name>ML_SMALL_METHOD_COUNT</name>
        <initializer>8</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="205" column="9" bodyfile="src/ml_method.c" bodystart="205" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ml__method_8c_1adbccf989131e3cd8ba91170005734e21" prot="public" static="no">
        <name>ML_METHODS_LOCK</name>
        <param></param>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="448" column="9" bodyfile="src/ml_method.c" bodystart="448" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="ml__method_8c_1abff33a311079ec134f0e2d2108f4e338" prot="public" static="no">
        <name>ML_METHODS_UNLOCK</name>
        <param></param>
        <initializer>{}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="449" column="9" bodyfile="src/ml_method.c" bodystart="449" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="ml__method_8c_1af28e23395a8c7b9d4a083c16b981d70a" prot="public" static="no">
        <type>struct ml_method_definition_t</type>
        <definition>typedef struct ml_method_definition_t ml_method_definition_t</definition>
        <argsstring></argsstring>
        <name>ml_method_definition_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="13" column="37" bodyfile="src/ml_method.c" bodystart="13" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="ml__method_8c_1a323aa39e74088f432d31ca3d137c32de" prot="public" static="yes" mutable="no">
        <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref></type>
        <definition>ml_methods_t MLRootMethods[1]</definition>
        <argsstring>[1]</argsstring>
        <name>MLRootMethods</name>
        <initializer>= {{
	MLMethodContextT, NULL,
	{INTHASH_INIT},
	{INTHASH_INIT},
	{INTHASH_INIT}



}}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="75" column="21" bodyfile="src/ml_method.c" bodystart="75" bodyend="83"/>
      </memberdef>
      <memberdef kind="variable" id="ml__method_8c_1aad686394dec1e374c9e60dcdaa35cf0b" prot="public" static="yes" mutable="no">
        <type><ref refid="structstringmap__t" kindref="compound">stringmap_t</ref></type>
        <definition>stringmap_t Methods[1]</definition>
        <argsstring>[1]</argsstring>
        <name>Methods</name>
        <initializer>= {STRINGMAP_INIT}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="325" column="20" bodyfile="src/ml_method.c" bodystart="325" bodyend="325"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="ml__method_8c_1a63b298cc3bca7bd3d4773e07d0f9f864" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_methods_call</definition>
        <argsstring>(ml_state_t *Caller, ml_methods_t *Methods, int Count, ml_value_t **Args)</argsstring>
        <name>ml_methods_call</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="35" column="13" bodyfile="src/ml_method.c" bodystart="35" bodyend="40"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a8eca45bb049068b155619a30b0dfaf69" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLMethodContextT,(), &quot;method::context&quot;,.call=(void *) ml_methods_call)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLMethodContextT</type>
        </param>
        <param>
          <type>()</type>
        </param>
        <param>
          <type>&quot;method::context&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>call</declname>
          <defval>(void *) ml_methods_call</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="42" column="1" declfile="src/ml_method.c" declline="42" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ab45524475cc30849007c536069da0d81" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_FUNCTIONX</definition>
        <argsstring>(MLMethodContext)</argsstring>
        <name>ML_FUNCTIONX</name>
        <param>
          <type>MLMethodContext</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="50" column="1" bodyfile="src/ml_method.c" bodystart="50" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a14ffc148b41f4bdcacc46ad68e821d2f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_FUNCTIONX</definition>
        <argsstring>(MLMethodIsolate)</argsstring>
        <name>ML_FUNCTIONX</name>
        <param>
          <type>MLMethodIsolate</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="60" column="1" bodyfile="src/ml_method.c" bodystart="60" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a4720570cf52d415113f148571dc0c592" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_methods_prevent_changes</definition>
        <argsstring>(ml_methods_t *Methods, int PreventChanges)</argsstring>
        <name>ml_methods_prevent_changes</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type>int</type>
          <declname>PreventChanges</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="85" column="6" bodyfile="src/ml_method.c" bodystart="85" bodyend="87"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ab2d202d7abdf90638c17cdfd6cb9effd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
        <definition>ml_methods_t * ml_methods_context</definition>
        <argsstring>(ml_context_t *Context)</argsstring>
        <name>ml_methods_context</name>
        <param>
          <type><ref refid="structml__context__t" kindref="compound">ml_context_t</ref> *</type>
          <declname>Context</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="89" column="14" bodyfile="src/ml_method.c" bodystart="89" bodyend="98"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a8b1e4d04f6d00ed78b728bbb4e6203a8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_methods_lock</definition>
        <argsstring>(ml_methods_t *Methods)</argsstring>
        <name>ml_methods_lock</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="100" column="20" bodyfile="src/ml_method.c" bodystart="100" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a32c0a35b662cec23e97dbb674fb1c5bd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_methods_unlock</definition>
        <argsstring>(ml_methods_t *Methods)</argsstring>
        <name>ml_methods_unlock</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="106" column="20" bodyfile="src/ml_method.c" bodystart="106" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a67bb5dc7af950eef9f75c213dcf1581a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>static</type>
        <definition>static __attribute__</definition>
        <argsstring>((pure))</argsstring>
        <name>__attribute__</name>
        <param>
          <type>(pure)</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="112" column="8" bodyfile="src/ml_method.c" bodystart="112" bodyend="127"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a25c3f9574cb79004b51f2e8e25e67064" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref> *</type>
        <definition>static ml_method_cached_t * ml_method_search_entry</definition>
        <argsstring>(ml_methods_t *Methods, ml_method_t *Method, int Count, ml_type_t **Types, uint64_t Hash)</argsstring>
        <name>ml_method_search_entry</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type><ref refid="structml__method__t" kindref="compound">ml_method_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> **</type>
          <declname>Types</declname>
        </param>
        <param>
          <type>uint64_t</type>
          <declname>Hash</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="169" column="34" bodyfile="src/ml_method.c" bodystart="169" bodyend="186" declfile="src/ml_method.c" declline="129" declcolumn="27"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ad62826e478a753740ffb406eeb04f274" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>static</type>
        <definition>__attribute__</definition>
        <argsstring>((noinline))</argsstring>
        <name>__attribute__</name>
        <param>
          <type>(noinline)</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="131" column="8" bodyfile="src/ml_method.c" bodystart="131" bodyend="167"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1af7ead48504d78951875c0088ba663eb8" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>uintptr_t</type>
        <definition>static uintptr_t rotl</definition>
        <argsstring>(uintptr_t X, unsigned int N)</argsstring>
        <name>rotl</name>
        <param>
          <type>uintptr_t</type>
          <declname>X</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="188" column="25" bodyfile="src/ml_method.c" bodystart="188" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a0fc75673f96ebaf344f82a82ceb54c1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref> *</type>
        <definition>ml_method_cached_t * ml_method_search_cached</definition>
        <argsstring>(ml_methods_t *Methods, ml_method_t *Method, int Count, ml_value_t **Args)</argsstring>
        <name>ml_method_search_cached</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type><ref refid="structml__method__t" kindref="compound">ml_method_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="236" column="20" bodyfile="src/ml_method.c" bodystart="236" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ac937fb4182678394b7e81c509eb2cba2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref> *</type>
        <definition>ml_method_cached_t * ml_method_check_cached</definition>
        <argsstring>(ml_methods_t *Methods, ml_method_t *Method, ml_method_cached_t *Cached, int Count, ml_value_t **Args)</argsstring>
        <name>ml_method_check_cached</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type><ref refid="structml__method__t" kindref="compound">ml_method_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref> *</type>
          <declname>Cached</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="256" column="20" bodyfile="src/ml_method.c" bodystart="256" bodyend="283"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1af62b9fef1c9ea9cff9bdc4311e791523" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_insert</definition>
        <argsstring>(ml_methods_t *Methods, ml_method_t *Method, ml_value_t *Callback, int Count, ml_type_t *Variadic, ml_type_t **Types)</argsstring>
        <name>ml_method_insert</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type><ref refid="structml__method__t" kindref="compound">ml_method_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Callback</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> *</type>
          <declname>Variadic</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> **</type>
          <declname>Types</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="285" column="6" bodyfile="src/ml_method.c" bodystart="285" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a97c748378d2d0beddd1257339e9c9e1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_define</definition>
        <argsstring>(ml_value_t *Value, ml_value_t *Function, int Count, ml_type_t *Variadic, ml_type_t **Types)</argsstring>
        <name>ml_method_define</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Function</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> *</type>
          <declname>Variadic</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> **</type>
          <declname>Types</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="306" column="6" bodyfile="src/ml_method.c" bodystart="306" bodyend="309"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ac14ba6a54132392a062940c5869b60e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_definev</definition>
        <argsstring>(ml_value_t *Method, ml_value_t *Function, ml_type_t *Variadic,...)</argsstring>
        <name>ml_method_definev</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Function</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> *</type>
          <declname>Variadic</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="311" column="6" bodyfile="src/ml_method.c" bodystart="311" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1afc017fa72ff6d025bef7e1b18c3eb015" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char * ml_method_name</definition>
        <argsstring>(const ml_value_t *Value)</argsstring>
        <name>ml_method_name</name>
        <param>
          <type>const <ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="327" column="12" bodyfile="src/ml_method.c" bodystart="327" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a157dc785ad019151703c44d4fe52061c" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>long</type>
        <definition>static long ml_method_hash</definition>
        <argsstring>(ml_value_t *Value, ml_hash_chain_t *Chain)</argsstring>
        <name>ml_method_hash</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type><ref refid="structml__hash__chain__t" kindref="compound">ml_hash_chain_t</ref> *</type>
          <declname>Chain</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="331" column="13" bodyfile="src/ml_method.c" bodystart="331" bodyend="336"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1af9f75ea7e38ca0e7bf29a12a31f00281" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD_ANON</definition>
        <argsstring>(MLMethodDefault, &quot;method::default&quot;)</argsstring>
        <name>ML_METHOD_ANON</name>
        <param>
          <type>MLMethodDefault</type>
        </param>
        <param>
          <type>&quot;method::default&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="365" column="1" declfile="src/ml_method.c" declline="365" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1aef8b3be32ea981db2150748601f494f5" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_method_call</definition>
        <argsstring>(ml_state_t *Caller, ml_value_t *Value, int Count, ml_value_t **Args)</argsstring>
        <name>ml_method_call</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="367" column="13" bodyfile="src/ml_method.c" bodystart="367" bodyend="383"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1aac0ad85c5732f50d766d94e3ab5d73d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLMethodT,(MLFunctionT), &quot;method&quot;,.hash=ml_method_hash,.call=ml_method_call)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLMethodT</type>
        </param>
        <param>
          <type>(MLFunctionT)</type>
        </param>
        <param>
          <type>&quot;method&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>hash</declname>
          <defval>ml_method_hash</defval>
        </param>
        <param>
          <type>.</type>
          <declname>call</declname>
          <defval>ml_method_call</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="385" column="1" declfile="src/ml_method.c" declline="385" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a51ade70eca1abaec8efceb39455a2972" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLMethodAnonT,(MLMethodT), &quot;method::anon&quot;,.hash=ml_method_hash,.call=ml_method_call)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLMethodAnonT</type>
        </param>
        <param>
          <type>(MLMethodT)</type>
        </param>
        <param>
          <type>&quot;method::anon&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>hash</declname>
          <defval>ml_method_hash</defval>
          <briefdescription><para>internal </para>
</briefdescription>
        </param>
        <param>
          <type>.</type>
          <declname>call</declname>
          <defval>ml_method_call</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="399" column="1" declfile="src/ml_method.c" declline="399" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a598914e1b2cfd17a355fb486820ce0ed" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ML_TYPED_FN</definition>
        <argsstring>(ml_value_set_name, MLMethodAnonT, ml_method_t *Method, const char *Name)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_value_set_name</type>
        </param>
        <param>
          <type>MLMethodAnonT</type>
        </param>
        <param>
          <type><ref refid="structml__method__t" kindref="compound">ml_method_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="405" column="13" bodyfile="src/ml_method.c" bodystart="405" bodyend="407"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a91d9a8ee15e2f85813bcce46cfd6d1f7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODV</definition>
        <argsstring>(MLMethodDefault, MLMethodT)</argsstring>
        <name>ML_METHODV</name>
        <param>
          <type>MLMethodDefault</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="409" column="1" bodyfile="src/ml_method.c" bodystart="409" bodyend="436"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a5571269414087dfb17cd8d5d72504252" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_method</definition>
        <argsstring>(const char *Name)</argsstring>
        <name>ml_method</name>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="453" column="12" bodyfile="src/ml_method.c" bodystart="453" bodyend="470"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ad9aa68147963a0690e92a916c727a989" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_method_anon</definition>
        <argsstring>(const char *Name)</argsstring>
        <name>ml_method_anon</name>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="472" column="12" bodyfile="src/ml_method.c" bodystart="472" bodyend="477"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a0ad22e2e17abe70616fb572e1187d031" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ML_TYPED_FN</definition>
        <argsstring>(ml_value_is_constant, MLMethodT, ml_value_t *Value)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_value_is_constant</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="479" column="12" bodyfile="src/ml_method.c" bodystart="479" bodyend="481"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ab1b4657708e23c4bf130ad170d2cd51a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(MLMethodT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="483" column="1" bodyfile="src/ml_method.c" bodystart="483" bodyend="487"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a454fdeb9817d46f851c9ca25b7aa479b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(MLMethodT, MLStringT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>MLMethodT</type>
        </param>
        <param>
          <type>MLStringT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="489" column="1" bodyfile="src/ml_method.c" bodystart="489" bodyend="494"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a6b65fcd581b9d3a07290015be67d83d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;name&quot;, MLMethodT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;name&quot;</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="496" column="1" bodyfile="src/ml_method.c" bodystart="496" bodyend="502"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a3a21ef8f1249a4af5835a25973c87607" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_by_name</definition>
        <argsstring>(const char *Name, void *Data, ml_callback_t Callback,...)</argsstring>
        <name>ml_method_by_name</name>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>ml_callback_t</type>
          <declname>Callback</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="504" column="6" bodyfile="src/ml_method.c" bodystart="504" bodyend="517"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a03ab625e1f2a428f8e8aa3c98f2e6edb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_by_value</definition>
        <argsstring>(void *Value, void *Data, ml_callback_t Callback,...)</argsstring>
        <name>ml_method_by_value</name>
        <param>
          <type>void *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>ml_callback_t</type>
          <declname>Callback</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="519" column="6" bodyfile="src/ml_method.c" bodystart="519" bodyend="532"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a63f10787a11a3add438e948c227025e4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_methodx_by_name</definition>
        <argsstring>(const char *Name, void *Data, ml_callbackx_t Callback,...)</argsstring>
        <name>ml_methodx_by_name</name>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>ml_callbackx_t</type>
          <declname>Callback</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="534" column="6" bodyfile="src/ml_method.c" bodystart="534" bodyend="547"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a137c7a72afef5bcef64fc213aa48c6dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_methodx_by_value</definition>
        <argsstring>(void *Value, void *Data, ml_callbackx_t Callback,...)</argsstring>
        <name>ml_methodx_by_value</name>
        <param>
          <type>void *</type>
          <declname>Value</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>Data</declname>
        </param>
        <param>
          <type>ml_callbackx_t</type>
          <declname>Callback</declname>
        </param>
        <param>
          <type>...</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="549" column="6" bodyfile="src/ml_method.c" bodystart="549" bodyend="562"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a21fcd0687315829a3b74a7e62ee76158" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;append&quot;, MLStringBufferT, MLMethodT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;append&quot;</type>
        </param>
        <param>
          <type>MLStringBufferT</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="564" column="1" bodyfile="src/ml_method.c" bodystart="564" bodyend="570"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ad4e0affc89f5bc270a770be8b31e3b19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD</definition>
        <argsstring>(&quot;append&quot;, MLStringBufferT, MLMethodAnonT)</argsstring>
        <name>ML_METHOD</name>
        <param>
          <type>&quot;append&quot;</type>
        </param>
        <param>
          <type>MLStringBufferT</type>
        </param>
        <param>
          <type>MLMethodAnonT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="572" column="1" bodyfile="src/ml_method.c" bodystart="572" bodyend="578"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1af993549b1af7c9be17ecd9f6f6dbb6b8" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_method_switch</definition>
        <argsstring>(ml_state_t *Caller, ml_method_switch_t *Switch, int Count, ml_value_t **Args)</argsstring>
        <name>ml_method_switch</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__method__switch__t" kindref="compound">ml_method_switch_t</ref> *</type>
          <declname>Switch</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="610" column="13" bodyfile="src/ml_method.c" bodystart="610" bodyend="616"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a43c16f5c2c02387ab62ef98c8c155dfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLMethodSwitchT,(MLFunctionT), &quot;method-switch&quot;,.call=(void *) ml_method_switch)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLMethodSwitchT</type>
        </param>
        <param>
          <type>(MLFunctionT)</type>
        </param>
        <param>
          <type>&quot;method-switch&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>call</declname>
          <defval>(void *) ml_method_switch</defval>
          <briefdescription><para>internal </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="618" column="1" declfile="src/ml_method.c" declline="618" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1af48d752f9ed6ba815e78c4b94cf15bc1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_FUNCTION_INLINE</definition>
        <argsstring>(MLMethodSwitch)</argsstring>
        <name>ML_FUNCTION_INLINE</name>
        <param>
          <type>MLMethodSwitch</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>internal</para>
        </inbodydescription>
        <location file="src/ml_method.c" line="623" column="1" bodyfile="src/ml_method.c" bodystart="623" bodyend="640"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1abe6e561af47ebcbeb4999ef783d4de76" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_method_set</definition>
        <argsstring>(ml_methods_t *Methods, int NumTypes, ml_type_t *Variadic, ml_value_t **Args, ml_value_t *Function)</argsstring>
        <name>ml_method_set</name>
        <param>
          <type><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref> *</type>
          <declname>Methods</declname>
        </param>
        <param>
          <type>int</type>
          <declname>NumTypes</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> *</type>
          <declname>Variadic</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Function</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="642" column="20" bodyfile="src/ml_method.c" bodystart="642" bodyend="654"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a801b7d555e75d9d19b51c1ce39a42a4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHOD_ANON</definition>
        <argsstring>(MLMethodDefine, &quot;method::define&quot;)</argsstring>
        <name>ML_METHOD_ANON</name>
        <param>
          <type>MLMethodDefine</type>
        </param>
        <param>
          <type>&quot;method::define&quot;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="656" column="1" declfile="src/ml_method.c" declline="656" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a8231f82829e9469a1e3ceb94aa893432" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODVX</definition>
        <argsstring>(MLMethodDefine, MLMethodT)</argsstring>
        <name>ML_METHODVX</name>
        <param>
          <type>MLMethodDefine</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="659" column="1" bodyfile="src/ml_method.c" bodystart="659" bodyend="685"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1abc78c885c0a967aba1b0311857876235" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODVX</definition>
        <argsstring>(MLMethodDefine, MLTypeT)</argsstring>
        <name>ML_METHODVX</name>
        <param>
          <type>MLMethodDefine</type>
        </param>
        <param>
          <type>MLTypeT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>internal</para>
        </inbodydescription>
        <location file="src/ml_method.c" line="687" column="1" bodyfile="src/ml_method.c" bodystart="687" bodyend="716"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a3a4004f7418e3191f00bdc668811c4f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODX</definition>
        <argsstring>(&quot;list&quot;, MLMethodT)</argsstring>
        <name>ML_METHODX</name>
        <param>
          <type>&quot;list&quot;</type>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="718" column="1" bodyfile="src/ml_method.c" bodystart="718" bodyend="742"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a44c44dede8621dda501aa91f66ce9542" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void ml_method_function_call</definition>
        <argsstring>(ml_state_t *Caller, ml_method_instance_t *Instance, int Count, ml_value_t **Args)</argsstring>
        <name>ml_method_function_call</name>
        <param>
          <type><ref refid="structml__state__t" kindref="compound">ml_state_t</ref> *</type>
          <declname>Caller</declname>
        </param>
        <param>
          <type><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref> *</type>
          <declname>Instance</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> **</type>
          <declname>Args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="751" column="13" bodyfile="src/ml_method.c" bodystart="751" bodyend="761"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a4a65bb91e4742f6c153d0d8033969d10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_TYPE</definition>
        <argsstring>(MLMethodInstanceT,(MLFunctionT), &quot;method::instance&quot;,.call=(void *) ml_method_function_call)</argsstring>
        <name>ML_TYPE</name>
        <param>
          <type>MLMethodInstanceT</type>
        </param>
        <param>
          <type>(MLFunctionT)</type>
        </param>
        <param>
          <type>&quot;method::instance&quot;</type>
        </param>
        <param>
          <type>.</type>
          <declname>call</declname>
          <defval>(void *) ml_method_function_call</defval>
          <briefdescription><para>internal </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="763" column="1" declfile="src/ml_method.c" declline="763" declcolumn="1"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a2ec95fb11aa529ebe52e88dca9e76d4b" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ML_TYPED_FN</definition>
        <argsstring>(ml_function_source, MLMethodInstanceT, ml_method_instance_t *Instance, const char **Source, int *Line)</argsstring>
        <name>ML_TYPED_FN</name>
        <param>
          <type>ml_function_source</type>
        </param>
        <param>
          <type>MLMethodInstanceT</type>
        </param>
        <param>
          <type><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref> *</type>
          <declname>Instance</declname>
        </param>
        <param>
          <type>const char **</type>
          <declname>Source</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>Line</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="768" column="12" bodyfile="src/ml_method.c" bodystart="768" bodyend="770"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a96179f90b5f275e78c26660bc7d66b7c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
        <definition>ml_value_t * ml_method_wrap</definition>
        <argsstring>(ml_value_t *Function, int Count, ml_type_t **Types)</argsstring>
        <name>ml_method_wrap</name>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Function</declname>
        </param>
        <param>
          <type>int</type>
          <declname>Count</declname>
        </param>
        <param>
          <type><ref refid="structml__type__t" kindref="compound">ml_type_t</ref> **</type>
          <declname>Types</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="772" column="12" bodyfile="src/ml_method.c" bodystart="772" bodyend="781"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a29174e9ba140bce53e531294d7bef889" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_METHODVX</definition>
        <argsstring>(&quot;[]&quot;, MLMethodT)</argsstring>
        <name>ML_METHODVX</name>
        <param>
          <type>&quot;&quot;</type>
          <array>[]</array>
        </param>
        <param>
          <type>MLMethodT</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="783" column="1" bodyfile="src/ml_method.c" bodystart="783" bodyend="815"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ac538741eed6461fd466a25d3eb1958f0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int ml_method_list_fn</definition>
        <argsstring>(const char *Name, ml_value_t *Method, ml_value_t *Result)</argsstring>
        <name>ml_method_list_fn</name>
        <param>
          <type>const char *</type>
          <declname>Name</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Method</declname>
        </param>
        <param>
          <type><ref refid="structml__value__t" kindref="compound">ml_value_t</ref> *</type>
          <declname>Result</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="817" column="12" bodyfile="src/ml_method.c" bodystart="817" bodyend="820"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1a1563a6390237e3097b3fc61b5a258774" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>ML_FUNCTION</definition>
        <argsstring>(MLMethodList)</argsstring>
        <name>ML_FUNCTION</name>
        <param>
          <type>MLMethodList</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="822" column="1" bodyfile="src/ml_method.c" bodystart="822" bodyend="829"/>
      </memberdef>
      <memberdef kind="function" id="ml__method_8c_1ad60ad47b37ea4a4c4a64c5a0d6464768" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void ml_method_init</definition>
        <argsstring>()</argsstring>
        <name>ml_method_init</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="src/ml_method.c" line="831" column="6" bodyfile="src/ml_method.c" bodystart="831" bodyend="842"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;ml_method.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;minilang.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ml_macros.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdatomic.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#undef<sp/>ML_CATEGORY</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_CATEGORY<sp/>&quot;method&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref>;</highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight></codeline>
<codeline lineno="15" refid="structml__method__definition__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>{</highlight></codeline>
<codeline lineno="16"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*Next;</highlight></codeline>
<codeline lineno="17"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Callback;</highlight></codeline>
<codeline lineno="18"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic;</highlight></codeline>
<codeline lineno="19"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count;</highlight></codeline>
<codeline lineno="20"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[];</highlight></codeline>
<codeline lineno="21"><highlight class="normal">};</highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight></codeline>
<codeline lineno="23" refid="structml__methods__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>{</highlight></codeline>
<codeline lineno="24"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="25"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Parent;</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structinthash__t" kindref="compound">inthash_t</ref><sp/>Cache[1];</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structinthash__t" kindref="compound">inthash_t</ref><sp/>Definitions[1];</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structinthash__t" kindref="compound">inthash_t</ref><sp/>Methods[1];</highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>atomic_flag<sp/>Lock[1];</highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>PreventChanges;</highlight></codeline>
<codeline lineno="33"><highlight class="normal">};</highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methods_call(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>ml_state(Caller);</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Context-&gt;Values[ML_METHODS_INDEX]<sp/>=<sp/>Methods;</highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function<sp/>=<sp/>ml_deref(Args[Count<sp/>-<sp/>1]);</highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>Function,<sp/>Count<sp/>-<sp/>1,<sp/>Args);</highlight></codeline>
<codeline lineno="40"><highlight class="normal">}</highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal">ML_TYPE(MLMethodContextT,<sp/>(),<sp/></highlight><highlight class="stringliteral">&quot;method::context&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>context<sp/>for<sp/>isolating<sp/>method<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="comment">//<sp/>:mini:`(C:<sp/>method::context)(Args:<sp/>any,<sp/>...,<sp/>Fn:<sp/>function):<sp/>any`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/>Calls<sp/>:mini:`Fn(Args)`<sp/>in<sp/>a<sp/>new<sp/>context<sp/>using<sp/>:mini:`C`<sp/>for<sp/>method<sp/>definitions.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>.call<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_methods_call</highlight></codeline>
<codeline lineno="48"><highlight class="normal">);</highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal">ML_FUNCTIONX(MLMethodContext)<sp/>{</highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight><highlight class="comment">//@method::context</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"></highlight><highlight class="comment">//&gt;method::context</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>context<sp/>for<sp/>method<sp/>definitions.<sp/>The<sp/>new<sp/>context<sp/>will<sp/>inherit<sp/>methods<sp/>definitions<sp/>from<sp/>the<sp/>current<sp/>context.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref>);</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Type<sp/>=<sp/>MLMethodContextT;</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Parent<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Methods);</highlight></codeline>
<codeline lineno="58"><highlight class="normal">}</highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal">ML_FUNCTIONX(MLMethodIsolate)<sp/>{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="comment">//@method::isolate</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight><highlight class="comment">//&lt;Args...</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight><highlight class="comment">//&lt;Fn:function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight><highlight class="comment">//&gt;any</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Evaluates<sp/>:mini:`Fn(Args)`<sp/>in<sp/>a<sp/>new<sp/>method<sp/>context<sp/>and<sp/>returns<sp/>the<sp/>result.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*State<sp/>=<sp/>ml_state(Caller);</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref>);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Type<sp/>=<sp/>MLMethodContextT;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Parent<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/>State-&gt;Context-&gt;Values[ML_METHODS_INDEX]<sp/>=<sp/>Methods;</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function<sp/>=<sp/>ml_deref(Args[Count<sp/>-<sp/>1]);</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(State,<sp/>Function,<sp/>Count<sp/>-<sp/>1,<sp/>Args);</highlight></codeline>
<codeline lineno="73"><highlight class="normal">}</highlight></codeline>
<codeline lineno="74"><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>MLRootMethods[1]<sp/>=<sp/>{{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/>MLMethodContextT,<sp/>NULL,</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>{INTHASH_INIT},</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/>{INTHASH_INIT},</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>{INTHASH_INIT}</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>,<sp/>{ATOMIC_FLAG_INIT}</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal">}};</highlight></codeline>
<codeline lineno="84"><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methods_prevent_changes(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>PreventChanges)<sp/>{</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;PreventChanges<sp/>=<sp/>PreventChanges;</highlight></codeline>
<codeline lineno="87"><highlight class="normal">}</highlight></codeline>
<codeline lineno="88"><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*ml_methods_context(<ref refid="structml__context__t" kindref="compound">ml_context_t</ref><sp/>*Context)<sp/>{</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref>);</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Type<sp/>=<sp/>MLMethodContextT;</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Parent<sp/>=<sp/>Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods-&gt;Lock[0]<sp/>=<sp/>(atomic_flag)ATOMIC_FLAG_INIT;</highlight></codeline>
<codeline lineno="95"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/>Context-&gt;Values[ML_METHODS_INDEX]<sp/>=<sp/>Methods;</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Methods;</highlight></codeline>
<codeline lineno="98"><highlight class="normal">}</highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight></codeline>
<codeline lineno="100"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methods_lock(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods)<sp/>{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(atomic_flag_test_and_set(Methods-&gt;Lock));</highlight></codeline>
<codeline lineno="103"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal">}</highlight></codeline>
<codeline lineno="105"><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methods_unlock(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods)<sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>atomic_flag_clear(Methods-&gt;Lock);</highlight></codeline>
<codeline lineno="109"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="110"><highlight class="normal">}</highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>__attribute__<sp/>((pure))<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ml_method_definition_score(<ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*Definition,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types)<sp/>{</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Score<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Definition-&gt;Count<sp/>&gt;<sp/>Count)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Definition-&gt;Count<sp/>&lt;<sp/>Count)<sp/>{</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Definition-&gt;Variadic)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Count<sp/>=<sp/>Definition-&gt;Count;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Definition-&gt;Variadic)<sp/>{</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Score<sp/>=<sp/>2;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Definition-&gt;Types[I];</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_is_subtype(Types[I],<sp/>Type))<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Score<sp/>+=<sp/>5<sp/>+<sp/>Type-&gt;Rank;</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Score;</highlight></codeline>
<codeline lineno="127"><highlight class="normal">}</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_search_entry(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types,<sp/>uint64_t<sp/>Hash);</highlight></codeline>
<codeline lineno="130"><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>__attribute__<sp/>((noinline))<sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_compute(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types,<sp/>uint64_t<sp/>Hash,<sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached)<sp/>{</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>BestScore<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*BestCallback<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*Definition<sp/>=<sp/>inthash_search(Methods-&gt;Definitions,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Definition)<sp/>{</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Score<sp/>=<sp/>ml_method_definition_score(Definition,<sp/>Count,<sp/>Types);</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Score<sp/>&gt;<sp/>BestScore)<sp/>{</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BestScore<sp/>=<sp/>Score;</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BestCallback<sp/>=<sp/>Definition-&gt;Callback;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Definition<sp/>=<sp/>Definition-&gt;Next;</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Methods-&gt;Parent)<sp/>{</highlight></codeline>
<codeline lineno="144"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached2<sp/>=<sp/>ml_method_search_entry(Methods-&gt;Parent,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached2<sp/>&amp;&amp;<sp/>Cached2-&gt;Score<sp/>&gt;<sp/>BestScore)<sp/>{</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BestScore<sp/>=<sp/>Cached2-&gt;Score;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>BestCallback<sp/>=<sp/>Cached2-&gt;Callback;</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!BestCallback)<sp/>{</highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="152"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cached)<sp/>{</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached<sp/>=<sp/>xnew(<ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref>,<sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*);</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;Methods<sp/>=<sp/>Methods;</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;Method<sp/>=<sp/>Method;</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;Count<sp/>=<sp/>Count;</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>Cached-&gt;Types[I]<sp/>=<sp/>Types[I];</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;Next<sp/>=<sp/>inthash_insert(Methods-&gt;Cache,<sp/>Hash,<sp/>Cached);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;MethodNext<sp/>=<sp/>inthash_insert(Methods-&gt;Methods,<sp/>(uintptr_t)Method,<sp/>Cached);</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/>Cached-&gt;Callback<sp/>=<sp/>BestCallback;</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/>Cached-&gt;Score<sp/>=<sp/>BestScore;</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Cached;</highlight></codeline>
<codeline lineno="167"><highlight class="normal">}</highlight></codeline>
<codeline lineno="168"><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_search_entry(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types,<sp/>uint64_t<sp/>Hash)<sp/>{</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_methods_lock(Methods);</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structinthash__t" kindref="compound">inthash_t</ref><sp/>*Cache<sp/>=<sp/>Methods-&gt;Cache;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached<sp/>=<sp/>inthash_search_inline(Cache,<sp/>Hash);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Cached)<sp/>{</highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached-&gt;Method<sp/>!=<sp/>Method)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>next;</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached-&gt;Count<sp/>!=<sp/>Count)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>next;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached-&gt;Types[I]<sp/>!=<sp/>Types[I])<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>next;</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cached-&gt;Callback)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Cached;</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/>next:</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached<sp/>=<sp/>Cached-&gt;Next;</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_compute(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash,<sp/>Cached);</highlight></codeline>
<codeline lineno="186"><highlight class="normal">}</highlight></codeline>
<codeline lineno="187"><highlight class="normal"></highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>uintptr_t<sp/>rotl(uintptr_t<sp/>X,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>N)<sp/>{</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Mask<sp/>=<sp/>(CHAR_BIT<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(uintptr_t)<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(X<sp/>&lt;&lt;<sp/>(N<sp/>&amp;<sp/>Mask))<sp/>|<sp/>(X<sp/>&gt;&gt;<sp/>((-N)<sp/>&amp;<sp/>Mask<sp/>));</highlight></codeline>
<codeline lineno="191"><highlight class="normal">}</highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>__attribute__<sp/>((noinline))<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_method_search2(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count];</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Types[I]<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Type;</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached<sp/>=<sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Cached-&gt;Callback;</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="203"><highlight class="normal">}</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_SMALL_METHOD_COUNT<sp/>8</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_NANBOXING</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/>__attribute__<sp/>((noinline))</highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_method_search(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Use<sp/>generation<sp/>numbers<sp/>to<sp/>check<sp/>Methods-&gt;Parent<sp/>for<sp/>invalidated<sp/>definitions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Count<sp/>&gt;<sp/>ML_SMALL_METHOD_COUNT)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search2(Methods,<sp/>Method,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[ML_SMALL_METHOD_COUNT];</highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Types[I]<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Type;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached<sp/>=<sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Cached-&gt;Callback;</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="224"><highlight class="normal">}</highlight></codeline>
<codeline lineno="225"><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/>__attribute__<sp/>((noinline))<sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_search_cached2(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count];</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Types[I]<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Type;</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="234"><highlight class="normal">}</highlight></codeline>
<codeline lineno="235"><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_search_cached(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Use<sp/>generation<sp/>numbers<sp/>to<sp/>check<sp/>Methods-&gt;Parent<sp/>for<sp/>invalidated<sp/>definitions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods<sp/>?:<sp/>MLRootMethods;</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Methods-&gt;Parent)<sp/>{</highlight></codeline>
<codeline lineno="240"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_lock(Methods);</highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Present<sp/>=<sp/>inthash_search(Methods-&gt;Definitions,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Present)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods-&gt;Parent;</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Count<sp/>&gt;<sp/>ML_SMALL_METHOD_COUNT)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search_cached2(Methods,<sp/>Method,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[ML_SMALL_METHOD_COUNT];</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Types[I]<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Type;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="254"><highlight class="normal">}</highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="256"><highlight class="normal"><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*ml_method_check_cached(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Use<sp/>generation<sp/>numbers<sp/>to<sp/>check<sp/>Methods-&gt;Parent<sp/>for<sp/>invalidated<sp/>definitions</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods<sp/>?:<sp/>MLRootMethods;</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Methods-&gt;Parent)<sp/>{</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_lock(Methods);</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Present<sp/>=<sp/>inthash_search(Methods-&gt;Definitions,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Present)<sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods-&gt;Parent;</highlight></codeline>
<codeline lineno="265"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached<sp/>&amp;&amp;<sp/>Cached-&gt;Methods<sp/>==<sp/>Methods)<sp/>{</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cached-&gt;Callback)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>missed;</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Cached-&gt;Count<sp/>!=<sp/>Count)<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>missed;</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_typeof_deref(Args[I])<sp/>!=<sp/>Cached-&gt;Types[I])<sp/></highlight><highlight class="keywordflow">goto</highlight><highlight class="normal"><sp/>missed;</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Cached;</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="274"><highlight class="normal">missed:</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Count<sp/>&gt;<sp/>ML_SMALL_METHOD_COUNT)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search_cached2(Methods,<sp/>Method,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[ML_SMALL_METHOD_COUNT];</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>Types[I]<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Type;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>Types,<sp/>Hash);</highlight></codeline>
<codeline lineno="283"><highlight class="normal">}</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_insert(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Callback,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types)<sp/>{</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_is((<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Method,<sp/>MLMethodT))<sp/>{</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stderr,<sp/></highlight><highlight class="stringliteral">&quot;Internal<sp/>error:<sp/>attempting<sp/>to<sp/>define<sp/>method<sp/>for<sp/>non-method<sp/>value\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exit(-1);</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*Definition<sp/>=<sp/>xnew(<ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref>,<sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/>Definition-&gt;Callback<sp/>=<sp/>Callback;</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/>Definition-&gt;Count<sp/>=<sp/>Count;</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/>Definition-&gt;Variadic<sp/>=<sp/>Variadic;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(Definition-&gt;Types,<sp/>Types,<sp/>Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*));</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_methods_lock(Methods);</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/>Definition-&gt;Next<sp/>=<sp/>inthash_insert(Methods-&gt;Definitions,<sp/>(uintptr_t)Method,<sp/>Definition);</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached<sp/>=<sp/>inthash_search(Methods-&gt;Methods,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Cached)<sp/>{</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>Only<sp/>invalidate<sp/>cached<sp/>entries<sp/>that<sp/>are<sp/>superseeded<sp/>by<sp/>this<sp/>definition</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached-&gt;Callback<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Cached<sp/>=<sp/>Cached-&gt;MethodNext;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_methods_unlock(Methods);</highlight></codeline>
<codeline lineno="304"><highlight class="normal">}</highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_define(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types)<sp/>{</highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value;</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>Method,<sp/>Function,<sp/>Count,<sp/>Variadic,<sp/>Types);</highlight></codeline>
<codeline lineno="309"><highlight class="normal">}</highlight></codeline>
<codeline lineno="310"><highlight class="normal"></highlight></codeline>
<codeline lineno="311"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_definev(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Method,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="313"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>Args;</highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Variadic);</highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>++Count;</highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count],<sp/>**T<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Variadic);</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>*T++<sp/>=<sp/>Type;</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Method,<sp/>Function,<sp/>Count,<sp/>Variadic,<sp/>Types);</highlight></codeline>
<codeline lineno="323"><highlight class="normal">}</highlight></codeline>
<codeline lineno="324"><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="structstringmap__t" kindref="compound">stringmap_t</ref><sp/>Methods[1]<sp/>=<sp/>{STRINGMAP_INIT};</highlight></codeline>
<codeline lineno="326"><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*ml_method_name(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value)-&gt;Name;</highlight></codeline>
<codeline lineno="329"><highlight class="normal">}</highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight></codeline>
<codeline lineno="331"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>ml_method_hash(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value,<sp/><ref refid="structml__hash__chain__t" kindref="compound">ml_hash_chain_t</ref><sp/>*Chain)<sp/>{</highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value;</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/>Hash<sp/>=<sp/>5381;</highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*P<sp/>=<sp/>Method-&gt;Name;<sp/>P[0];<sp/>++P)<sp/>Hash<sp/>=<sp/>((Hash<sp/>&lt;&lt;<sp/>5)<sp/>+<sp/>Hash)<sp/>+<sp/>P[0];</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Hash;</highlight></codeline>
<codeline lineno="336"><highlight class="normal">}</highlight></codeline>
<codeline lineno="337"><highlight class="normal"></highlight></codeline>
<codeline lineno="338"><highlight class="normal">__attribute__<sp/>((noinline))<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_no_method_error(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Type<sp/>==<sp/>MLUninitializedT)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;ValueError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;%s<sp/>is<sp/>uninitialized&quot;</highlight><highlight class="normal">,<sp/>ml_uninitialized_name(ml_deref(Args[I])));</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Length<sp/>+=<sp/>strlen(Type-&gt;Name)<sp/>+<sp/>2;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Types<sp/>=<sp/>snew(Length);</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/>Types[0]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*P<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="348"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__MINGW32__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/>Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>strlen(Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="355"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>=<sp/>stpcpy(stpcpy(P,<sp/>Type-&gt;Name),<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/>P[-2]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;MethodError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;no<sp/>method<sp/>found<sp/>for<sp/>%s(%s)&quot;</highlight><highlight class="normal">,<sp/>Method-&gt;Name,<sp/>Types);</highlight></codeline>
<codeline lineno="363"><highlight class="normal">}</highlight></codeline>
<codeline lineno="364"><highlight class="normal"></highlight></codeline>
<codeline lineno="365"><highlight class="normal">ML_METHOD_ANON(MLMethodDefault,<sp/></highlight><highlight class="stringliteral">&quot;method::default&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_call(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value;</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Methods-&gt;Parent<sp/>&amp;&amp;<sp/>!inthash_contains_inline(Methods-&gt;Definitions,<sp/>(uintptr_t)Method))<sp/>{</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods-&gt;Parent;</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Callback<sp/>=<sp/>ml_method_search(Methods,<sp/>Method,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(__builtin_expect(Callback<sp/>!=<sp/>NULL,<sp/>1))<sp/>{</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(Caller,<sp/>Callback,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ML_RETURN(ml_no_method_error(Method,<sp/>Count,<sp/>Args));</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args2<sp/>=<sp/>ml_alloc_args(Count<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memmove(Args2<sp/>+<sp/>1,<sp/>Args,<sp/>Count<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*));</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args2[0]<sp/>=<sp/>Value;</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(Caller,<sp/>MLMethodDefault,<sp/>Count<sp/>+<sp/>1,<sp/>Args2);</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="383"><highlight class="normal">}</highlight></codeline>
<codeline lineno="384"><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal">ML_TYPE(MLMethodT,<sp/>(MLFunctionT),<sp/></highlight><highlight class="stringliteral">&quot;method&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="386"><highlight class="normal"></highlight><highlight class="comment">//<sp/>A<sp/>map<sp/>of<sp/>type<sp/>signatures<sp/>to<sp/>functions.<sp/>Each<sp/>type<sp/>signature<sp/>consists<sp/>of<sp/>a<sp/>number<sp/>of<sp/>types<sp/>and<sp/>a<sp/>flag<sp/>denoting<sp/>whether<sp/>the<sp/>signature<sp/>is<sp/>variadic.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="387"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal"></highlight><highlight class="comment">//<sp/>:mini:`(M:<sp/>method)(Arg/1,<sp/>...,<sp/>Arg/n)`</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="389"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>Calls<sp/>:mini:`Fn(Arg/1,<sp/>...,<sp/>Arg/n)`<sp/>where<sp/>:mini:`Fn`<sp/>is<sp/>the<sp/>function<sp/>associated<sp/>with<sp/>the<sp/>closest<sp/>matching<sp/>type<sp/>signature<sp/>defined<sp/>in<sp/>:mini:`M`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="390"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="391"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>A<sp/>type<sp/>signature<sp/>:mini:`(Type/1,<sp/>...,<sp/>Type/k,<sp/>Variadic)`<sp/>matches<sp/>if<sp/>:mini:`type(Arg/i)<sp/>&lt;<sp/>Type/i`<sp/>for<sp/>each<sp/>:math:`i<sp/>=<sp/>1,<sp/>...,<sp/>k`<sp/>and<sp/>either<sp/>:math:`n<sp/>=<sp/>k`<sp/>or<sp/>:math:`n<sp/>&lt;<sp/>k`<sp/>and<sp/>:math:`Variadic`<sp/>is<sp/>true.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="393"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>*<sp/>A<sp/>type<sp/>signature<sp/>is<sp/>considered<sp/>a<sp/>closer<sp/>match<sp/>if<sp/>its<sp/>types<sp/>are<sp/>closer<sp/>in<sp/>terms<sp/>of<sp/>subtyping<sp/>to<sp/>the<sp/>types<sp/>of<sp/>the<sp/>arguments.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/>*<sp/>A<sp/>type<sp/>signature<sp/>with<sp/>the<sp/>same<sp/>number<sp/>of<sp/>types<sp/>as<sp/>arguments<sp/>is<sp/>considered<sp/>a<sp/>closer<sp/>match<sp/>than<sp/>a<sp/>matching<sp/>variadic<sp/>signature<sp/>with<sp/>fewer<sp/>types.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/>.hash<sp/>=<sp/>ml_method_hash,</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/>.call<sp/>=<sp/>ml_method_call</highlight></codeline>
<codeline lineno="397"><highlight class="normal">);</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal">ML_TYPE(MLMethodAnonT,<sp/>(MLMethodT),<sp/></highlight><highlight class="stringliteral">&quot;method::anon&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>.hash<sp/>=<sp/>ml_method_hash,</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/>.call<sp/>=<sp/>ml_method_call</highlight></codeline>
<codeline lineno="403"><highlight class="normal">);</highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_value_set_name,<sp/>MLMethodAnonT,<sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name)<sp/>{</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/>Method-&gt;Name<sp/>=<sp/>Name;</highlight></codeline>
<codeline lineno="407"><highlight class="normal">}</highlight></codeline>
<codeline lineno="408"><highlight class="normal"></highlight></codeline>
<codeline lineno="409"><highlight class="normal">ML_METHODV(MLMethodDefault,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//printf(&quot;Calling<sp/>default<sp/>method<sp/>for<sp/>%s&quot;,<sp/>Method-&gt;Name);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Type<sp/>==<sp/>MLUninitializedT)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;ValueError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;%s<sp/>is<sp/>uninitialized&quot;</highlight><highlight class="normal">,<sp/>ml_uninitialized_name(ml_deref(Args[I])));</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Length<sp/>+=<sp/>strlen(Type-&gt;Name)<sp/>+<sp/>2;</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Types<sp/>=<sp/>snew(Length);</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>Types[0]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*P<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="421"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__MINGW32__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/>Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>strlen(Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="428"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="430"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="431"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>=<sp/>stpcpy(stpcpy(P,<sp/>Type-&gt;Name),<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="432"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="433"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="434"><highlight class="normal"><sp/><sp/><sp/><sp/>P[-2]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="435"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;MethodError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;no<sp/>method<sp/>found<sp/>for<sp/>%s(%s)&quot;</highlight><highlight class="normal">,<sp/>Method-&gt;Name,<sp/>Types);</highlight></codeline>
<codeline lineno="436"><highlight class="normal">}</highlight></codeline>
<codeline lineno="437"><highlight class="normal"></highlight></codeline>
<codeline lineno="438"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>ML_THREADSAFE</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="normal"></highlight></codeline>
<codeline lineno="440"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">volatile</highlight><highlight class="normal"><sp/>atomic_flag<sp/>MLMethodsLock[1]<sp/>=<sp/>{ATOMIC_FLAG_INIT};</highlight></codeline>
<codeline lineno="441"><highlight class="normal"></highlight></codeline>
<codeline lineno="442"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_METHODS_LOCK()<sp/>while<sp/>(atomic_flag_test_and_set(MLMethodsLock))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="443"><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_METHODS_UNLOCK()<sp/>atomic_flag_clear(MLMethodsLock)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="445"><highlight class="normal"></highlight></codeline>
<codeline lineno="446"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="447"><highlight class="normal"></highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_METHODS_LOCK()<sp/>{}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>ML_METHODS_UNLOCK()<sp/>{}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="450"><highlight class="normal"></highlight></codeline>
<codeline lineno="451"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="452"><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_method(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name)<sp/>{</highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Name)<sp/>{</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref>);</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Method-&gt;Type<sp/>=<sp/>MLMethodAnonT;</highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>GC_asprintf((</highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**)&amp;Method-&gt;Name,<sp/></highlight><highlight class="stringliteral">&quot;&lt;anon:0x%lx&gt;&quot;</highlight><highlight class="normal">,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Method;</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_METHODS_LOCK();</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>**Slot<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>**)stringmap_slot(Methods,<sp/>Name);</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Slot[0])<sp/>{</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref>);</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Method-&gt;Type<sp/>=<sp/>MLMethodT;</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Method-&gt;Name<sp/>=<sp/>Name;</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Slot[0]<sp/>=<sp/>Method;</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_METHODS_UNLOCK();</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Slot[0];</highlight></codeline>
<codeline lineno="470"><highlight class="normal">}</highlight></codeline>
<codeline lineno="471"><highlight class="normal"></highlight></codeline>
<codeline lineno="472"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_method_anon(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name)<sp/>{</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref>);</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/>Method-&gt;Type<sp/>=<sp/>MLMethodAnonT;</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>Method-&gt;Name<sp/>=<sp/>Name;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Method;</highlight></codeline>
<codeline lineno="477"><highlight class="normal">}</highlight></codeline>
<codeline lineno="478"><highlight class="normal"></highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_value_is_constant,<sp/>MLMethodT,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value)<sp/>{</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="481"><highlight class="normal">}</highlight></codeline>
<codeline lineno="482"><highlight class="normal"></highlight></codeline>
<codeline lineno="483"><highlight class="normal">ML_METHOD(MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="484"><highlight class="normal"></highlight><highlight class="comment">//&gt;method</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="485"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>a<sp/>new<sp/>anonymous<sp/>method.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method(NULL);</highlight></codeline>
<codeline lineno="487"><highlight class="normal">}</highlight></codeline>
<codeline lineno="488"><highlight class="normal"></highlight></codeline>
<codeline lineno="489"><highlight class="normal">ML_METHOD(MLMethodT,<sp/>MLStringT)<sp/>{</highlight></codeline>
<codeline lineno="490"><highlight class="normal"></highlight><highlight class="comment">//&lt;Name</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"></highlight><highlight class="comment">//&gt;method</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="492"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>method<sp/>with<sp/>name<sp/>:mini:`Name`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_method(ml_string_value(Args[0]));</highlight></codeline>
<codeline lineno="494"><highlight class="normal">}</highlight></codeline>
<codeline lineno="495"><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="497"><highlight class="normal"></highlight><highlight class="comment">//&lt;Method</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="498"><highlight class="normal"></highlight><highlight class="comment">//&gt;string</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="499"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Returns<sp/>the<sp/>name<sp/>of<sp/>:mini:`Method`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_string(Method-&gt;Name,<sp/>-1);</highlight></codeline>
<codeline lineno="502"><highlight class="normal">}</highlight></codeline>
<codeline lineno="503"><highlight class="normal"></highlight></codeline>
<codeline lineno="504"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_by_name(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/>ml_callback_t<sp/>Callback,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)ml_method(Name);</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>Args;</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>++Count;</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count],<sp/>**T<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>*T++<sp/>=<sp/>Type;</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>Method,<sp/>ml_cfunction(Data,<sp/>Callback),<sp/>Count,<sp/>MLAnyT,<sp/>Types);</highlight></codeline>
<codeline lineno="517"><highlight class="normal">}</highlight></codeline>
<codeline lineno="518"><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_by_value(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Value,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/>ml_callback_t<sp/>Callback,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>Args;</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>++Count;</highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count],<sp/>**T<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>*T++<sp/>=<sp/>Type;</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>Method,<sp/>ml_cfunction(Data,<sp/>Callback),<sp/>Count,<sp/>MLAnyT,<sp/>Types);</highlight></codeline>
<codeline lineno="532"><highlight class="normal">}</highlight></codeline>
<codeline lineno="533"><highlight class="normal"></highlight></codeline>
<codeline lineno="534"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methodx_by_name(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/>ml_callbackx_t<sp/>Callback,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)ml_method(Name);</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>Args;</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>++Count;</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count],<sp/>**T<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>*T++<sp/>=<sp/>Type;</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>Method,<sp/>ml_cfunctionx(Data,<sp/>Callback),<sp/>Count,<sp/>MLAnyT,<sp/>Types);</highlight></codeline>
<codeline lineno="547"><highlight class="normal">}</highlight></codeline>
<codeline lineno="548"><highlight class="normal"></highlight></codeline>
<codeline lineno="549"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_methodx_by_value(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Value,<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*Data,<sp/>ml_callbackx_t<sp/>Callback,<sp/>...)<sp/>{</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Value;</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/>va_list<sp/>Args;</highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>++Count;</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Types[Count],<sp/>**T<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/>va_start(Args,<sp/>Callback);</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>((Type<sp/>=<sp/>va_arg(Args,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)))<sp/>*T++<sp/>=<sp/>Type;</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/>va_end(Args);</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(MLRootMethods,<sp/>Method,<sp/>ml_cfunctionx(Data,<sp/>Callback),<sp/>Count,<sp/>MLAnyT,<sp/>Types);</highlight></codeline>
<codeline lineno="562"><highlight class="normal">}</highlight></codeline>
<codeline lineno="563"><highlight class="normal"></highlight></codeline>
<codeline lineno="564"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;append&quot;</highlight><highlight class="normal">,<sp/>MLStringBufferT,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*Buffer<sp/>=<sp/>(<ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_put(Buffer,<sp/></highlight><highlight class="charliteral">&apos;:&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_write(Buffer,<sp/>Method-&gt;Name,<sp/>strlen(Method-&gt;Name));</highlight></codeline>
<codeline lineno="569"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLSome;</highlight></codeline>
<codeline lineno="570"><highlight class="normal">}</highlight></codeline>
<codeline lineno="571"><highlight class="normal"></highlight></codeline>
<codeline lineno="572"><highlight class="normal">ML_METHOD(</highlight><highlight class="stringliteral">&quot;append&quot;</highlight><highlight class="normal">,<sp/>MLStringBufferT,<sp/>MLMethodAnonT)<sp/>{</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*Buffer<sp/>=<sp/>(<ref refid="structml__stringbuffer__t" kindref="compound">ml_stringbuffer_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[1];</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_put(Buffer,<sp/></highlight><highlight class="charliteral">&apos;@&apos;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="576"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_stringbuffer_write(Buffer,<sp/>Method-&gt;Name,<sp/>strlen(Method-&gt;Name));</highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>MLSome;</highlight></codeline>
<codeline lineno="578"><highlight class="normal">}</highlight></codeline>
<codeline lineno="579"><highlight class="normal"></highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight><highlight class="comment">/*ML_METHODVX(&quot;[]&quot;,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="581"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_method_t<sp/>*Method<sp/>=<sp/>(ml_method_t<sp/>*)Args[0];</highlight></codeline>
<codeline lineno="582"><highlight class="comment"><sp/><sp/><sp/><sp/>for<sp/>(int<sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>ML_CHECKX_ARG_TYPE(I,<sp/>MLTypeT);</highlight></codeline>
<codeline lineno="583"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_value_t<sp/>*Matches<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="584"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_type_t<sp/>**Types<sp/>=<sp/>(ml_type_t<sp/>**)Args<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="585"><highlight class="comment"><sp/><sp/><sp/><sp/>--Count;</highlight></codeline>
<codeline lineno="586"><highlight class="comment"><sp/><sp/><sp/><sp/>ml_methods_t<sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="587"><highlight class="comment"><sp/><sp/><sp/><sp/>do<sp/>{</highlight></codeline>
<codeline lineno="588"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_method_definition_t<sp/>*Definition<sp/>=<sp/>inthash_search(Methods-&gt;Definitions,<sp/>(uintptr_t)Method);</highlight></codeline>
<codeline lineno="589"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(Definition)<sp/>{</highlight></codeline>
<codeline lineno="590"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unsigned<sp/>int<sp/>Score<sp/>=<sp/>ml_method_definition_score(Definition,<sp/>Count,<sp/>Types);</highlight></codeline>
<codeline lineno="591"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(Score)<sp/>{</highlight></codeline>
<codeline lineno="592"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_value_t<sp/>*Match<sp/>=<sp/>ml_tuple(2);</highlight></codeline>
<codeline lineno="593"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_tuple_set(Match,<sp/>1,<sp/>Definition-&gt;Callback);</highlight></codeline>
<codeline lineno="594"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_tuple_set(Match,<sp/>2,<sp/>ml_integer(Score));</highlight></codeline>
<codeline lineno="595"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_list_put(Matches,<sp/>Match);</highlight></codeline>
<codeline lineno="596"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="597"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Definition<sp/>=<sp/>Definition-&gt;Next;</highlight></codeline>
<codeline lineno="598"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="599"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods-&gt;Parent;</highlight></codeline>
<codeline lineno="600"><highlight class="comment"><sp/><sp/><sp/><sp/>}<sp/>while<sp/>(Methods);</highlight></codeline>
<codeline lineno="601"><highlight class="comment"><sp/><sp/><sp/><sp/>ML_RETURN(Matches);</highlight></codeline>
<codeline lineno="602"><highlight class="comment">}*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"></highlight></codeline>
<codeline lineno="604" refid="structml__method__switch__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Default;</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structinthash__t" kindref="compound">inthash_t</ref><sp/>Cases[1];</highlight></codeline>
<codeline lineno="608"><highlight class="normal">}<sp/><ref refid="structml__method__switch__t" kindref="compound">ml_method_switch_t</ref>;</highlight></codeline>
<codeline lineno="609"><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_switch(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__method__switch__t" kindref="compound">ml_method_switch_t</ref><sp/>*Switch,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_COUNT(1);</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(0,<sp/>MLMethodT);</highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Arg<sp/>=<sp/>ml_deref(Args[0]);</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Index<sp/>=<sp/>inthash_search(Switch-&gt;Cases,<sp/>(uintptr_t)Arg);</highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Index<sp/>?:<sp/>Switch-&gt;Default);</highlight></codeline>
<codeline lineno="616"><highlight class="normal">}</highlight></codeline>
<codeline lineno="617"><highlight class="normal"></highlight></codeline>
<codeline lineno="618"><highlight class="normal">ML_TYPE(MLMethodSwitchT,<sp/>(MLFunctionT),<sp/></highlight><highlight class="stringliteral">&quot;method-switch&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/>.call<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_method_switch</highlight></codeline>
<codeline lineno="621"><highlight class="normal">);</highlight></codeline>
<codeline lineno="622"><highlight class="normal"></highlight></codeline>
<codeline lineno="623"><highlight class="normal">ML_FUNCTION_INLINE(MLMethodSwitch)<sp/>{</highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>ML_CHECK_ARG_TYPE(I,<sp/>MLListT);</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__switch__t" kindref="compound">ml_method_switch_t</ref><sp/>*Switch<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__method__switch__t" kindref="compound">ml_method_switch_t</ref>);</highlight></codeline>
<codeline lineno="627"><highlight class="normal"><sp/><sp/><sp/><sp/>Switch-&gt;Type<sp/>=<sp/>MLMethodSwitchT;</highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="629"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_LIST_FOREACH(Args[I],<sp/>Iter)<sp/>{</highlight></codeline>
<codeline lineno="630"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Value<sp/>=<sp/>Iter-&gt;Value;</highlight></codeline>
<codeline lineno="631"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_is(Value,<sp/>MLMethodT))<sp/>{</highlight></codeline>
<codeline lineno="632"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>inthash_insert(Switch-&gt;Cases,<sp/>(uintptr_t)Value,<sp/>ml_integer(I));</highlight></codeline>
<codeline lineno="633"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="634"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_error(</highlight><highlight class="stringliteral">&quot;ValueError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Unsupported<sp/>value<sp/>in<sp/>method<sp/>case&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="635"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="637"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/>Switch-&gt;Default<sp/>=<sp/>ml_integer(Count);</highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Switch;</highlight></codeline>
<codeline lineno="640"><highlight class="normal">}</highlight></codeline>
<codeline lineno="641"><highlight class="normal"></highlight></codeline>
<codeline lineno="642"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_set(<ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NumTypes,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function)<sp/>{</highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Use<sp/>alloca<sp/>here,<sp/>VLA<sp/>prevents<sp/>TCO.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types<sp/>=<sp/>alloca(NumTypes<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*));</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;=<sp/>NumTypes;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="646"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Args[I]<sp/>==<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Types[I<sp/>-<sp/>1]<sp/>=<sp/>MLNilT;</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Types[I<sp/>-<sp/>1]<sp/>=<sp/>(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)Args[I];</highlight></codeline>
<codeline lineno="650"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_insert(Methods,<sp/>Method,<sp/>Function,<sp/>NumTypes,<sp/>Variadic,<sp/>Types);</highlight></codeline>
<codeline lineno="654"><highlight class="normal">}</highlight></codeline>
<codeline lineno="655"><highlight class="normal"></highlight></codeline>
<codeline lineno="656"><highlight class="normal">ML_METHOD_ANON(MLMethodDefine,<sp/></highlight><highlight class="stringliteral">&quot;method::define&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="657"><highlight class="normal"></highlight><highlight class="comment">//@method::define</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="658"><highlight class="normal"></highlight></codeline>
<codeline lineno="659"><highlight class="normal">ML_METHODVX(MLMethodDefine,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="660"><highlight class="normal"></highlight><highlight class="comment">//@method::define</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="661"><highlight class="normal"></highlight><highlight class="comment">//&lt;Method</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight><highlight class="comment">//&lt;Types...:type</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"></highlight><highlight class="comment">//&lt;..?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight><highlight class="comment">//&lt;Function:function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="665"><highlight class="normal"></highlight><highlight class="comment">//&gt;Function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Adds<sp/>a<sp/>new<sp/>type<sp/>signature<sp/>and<sp/>associated<sp/>function<sp/>to<sp/>:mini:`Method`.<sp/>If<sp/>the<sp/>last<sp/>argument<sp/>is<sp/>:mini:`..`<sp/>then<sp/>the<sp/>signature<sp/>is<sp/>variadic.<sp/>Method<sp/>definitions<sp/>using<sp/>:mini:`meth`<sp/>are<sp/>translated<sp/>into<sp/>calls<sp/>to<sp/>:mini:`method::set`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Methods-&gt;PreventChanges)<sp/>ML_ERROR(</highlight><highlight class="stringliteral">&quot;ContextError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Context<sp/>does<sp/>not<sp/>allow<sp/>methods<sp/>to<sp/>be<sp/>defined&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_COUNT(2);</highlight></codeline>
<codeline lineno="670"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NumTypes<sp/>=<sp/>Count<sp/>-<sp/>2;</highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Count<sp/>&gt;=<sp/>3<sp/>&amp;&amp;<sp/>ml_is(Args[Count<sp/>-<sp/>2],<sp/>MLListT))<sp/>{</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Variadic<sp/>=<sp/>MLAnyT;</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--NumTypes;</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;=<sp/>NumTypes;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Args[I]<sp/>!=<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(I,<sp/>MLTypeT);</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(Count<sp/>-<sp/>1,<sp/>MLFunctionT);</highlight></codeline>
<codeline lineno="682"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function<sp/>=<sp/>Args[Count<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_set(Methods,<sp/>NumTypes,<sp/>Variadic,<sp/>Args,<sp/>Function);</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Function);</highlight></codeline>
<codeline lineno="685"><highlight class="normal">}</highlight></codeline>
<codeline lineno="686"><highlight class="normal"></highlight></codeline>
<codeline lineno="687"><highlight class="normal">ML_METHODVX(MLMethodDefine,<sp/>MLTypeT)<sp/>{</highlight></codeline>
<codeline lineno="689"><highlight class="comment">//@method::define</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="690"><highlight class="normal"></highlight><highlight class="comment">//&lt;Type</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="691"><highlight class="normal"></highlight><highlight class="comment">//&lt;Types...:type</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight><highlight class="comment">//&lt;..?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="normal"></highlight><highlight class="comment">//&lt;Function:function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="694"><highlight class="normal"></highlight><highlight class="comment">//&gt;Function</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="695"><highlight class="normal"></highlight><highlight class="comment">//<sp/>Adds<sp/>a<sp/>new<sp/>type<sp/>signature<sp/>and<sp/>associated<sp/>function<sp/>to<sp/>:mini:`Method`.<sp/>If<sp/>the<sp/>last<sp/>argument<sp/>is<sp/>:mini:`..`<sp/>then<sp/>the<sp/>signature<sp/>is<sp/>variadic.<sp/>Method<sp/>definitions<sp/>using<sp/>:mini:`meth`<sp/>are<sp/>translated<sp/>into<sp/>calls<sp/>to<sp/>:mini:`method::set`.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="697"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Methods-&gt;PreventChanges)<sp/>ML_ERROR(</highlight><highlight class="stringliteral">&quot;ContextError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Context<sp/>does<sp/>not<sp/>allow<sp/>methods<sp/>to<sp/>be<sp/>defined&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_COUNT(2);</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/>Args[0]<sp/>=<sp/>((<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)Args[0])-&gt;Constructor;</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(0,<sp/>MLMethodT);</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>NumTypes<sp/>=<sp/>Count<sp/>-<sp/>2;</highlight></codeline>
<codeline lineno="702"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Variadic<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Count<sp/>&gt;=<sp/>3<sp/>&amp;&amp;<sp/>ml_is(Args[Count<sp/>-<sp/>2],<sp/>MLListT))<sp/>{</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Variadic<sp/>=<sp/>MLAnyT;</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>--NumTypes;</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="707"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>1;<sp/>I<sp/>&lt;=<sp/>NumTypes;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Args[I]<sp/>!=<sp/>MLNil)<sp/>{</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(I,<sp/>MLTypeT);</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="712"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(Count<sp/>-<sp/>1,<sp/>MLFunctionT);</highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function<sp/>=<sp/>Args[Count<sp/>-<sp/>1];</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_set(Methods,<sp/>NumTypes,<sp/>Variadic,<sp/>Args,<sp/>Function);</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Function);</highlight></codeline>
<codeline lineno="716"><highlight class="normal">}</highlight></codeline>
<codeline lineno="717"><highlight class="normal"></highlight></codeline>
<codeline lineno="718"><highlight class="normal">ML_METHODX(</highlight><highlight class="stringliteral">&quot;list&quot;</highlight><highlight class="normal">,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Results<sp/>=<sp/>ml_map();</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="722"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(<ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*Definition<sp/>=<sp/>(<ref refid="structml__method__definition__t" kindref="compound">ml_method_definition_t</ref><sp/>*)inthash_search(Methods-&gt;Definitions,<sp/>(uintptr_t)Args[0]);<sp/>Definition;<sp/>Definition<sp/>=<sp/>Definition-&gt;Next)<sp/>{</highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Signature<sp/>=<sp/>ml_tuple(Definition-&gt;Count<sp/>+<sp/>!!Definition-&gt;Variadic);</highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Definition-&gt;Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ml_tuple_set(Signature,<sp/>I<sp/>+<sp/>1,<sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Definition-&gt;Types[I]);</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="727"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(Definition-&gt;Variadic)<sp/>ml_tuple_set(Signature,<sp/>Definition-&gt;Count<sp/>+<sp/>1,<sp/>ml_list());</highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__map__node__t" kindref="compound">ml_map_node_t</ref><sp/>*Node<sp/>=<sp/>ml_map_slot(Results,<sp/>Signature);</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Node-&gt;Value)<sp/>{</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Source;</highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Line;</highlight></codeline>
<codeline lineno="732"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ml_function_source(Definition-&gt;Callback,<sp/>&amp;Source,<sp/>&amp;Line))<sp/>{</highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>ml_tuplev(2,<sp/>ml_string(Source,<sp/>-1),<sp/>ml_integer(Line));</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Node-&gt;Value<sp/>=<sp/>MLNil;</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="737"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Methods<sp/>=<sp/>Methods-&gt;Parent;</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(Methods);</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(Results);</highlight></codeline>
<codeline lineno="742"><highlight class="normal">}</highlight></codeline>
<codeline lineno="743"><highlight class="normal"></highlight></codeline>
<codeline lineno="744" refid="structml__method__instance__t" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Type;</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function;</highlight></codeline>
<codeline lineno="747"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types;</highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count;</highlight></codeline>
<codeline lineno="749"><highlight class="normal">}<sp/><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref>;</highlight></codeline>
<codeline lineno="750"><highlight class="normal"></highlight></codeline>
<codeline lineno="751"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_function_call(<ref refid="structml__state__t" kindref="compound">ml_state_t</ref><sp/>*Caller,<sp/><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref><sp/>*Instance,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>**Args)<sp/>{</highlight></codeline>
<codeline lineno="752"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_COUNT(Instance-&gt;Count);</highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Instance-&gt;Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Actual<sp/>=<sp/>ml_typeof_deref(Args[I]);</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*Expected<sp/>=<sp/>Instance-&gt;Types[I];</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!ml_is_subtype(Actual,<sp/>Expected))<sp/>{</highlight></codeline>
<codeline lineno="757"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_ERROR(</highlight><highlight class="stringliteral">&quot;TypeError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;expected<sp/>%s<sp/>for<sp/>argument<sp/>%d&quot;</highlight><highlight class="normal">,<sp/>Expected-&gt;Name,<sp/>I<sp/>+<sp/>1);</highlight></codeline>
<codeline lineno="758"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="759"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="760"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_call(Caller,<sp/>Instance-&gt;Function,<sp/>Count,<sp/>Args);</highlight></codeline>
<codeline lineno="761"><highlight class="normal">}</highlight></codeline>
<codeline lineno="762"><highlight class="normal"></highlight></codeline>
<codeline lineno="763"><highlight class="normal">ML_TYPE(MLMethodInstanceT,<sp/>(MLFunctionT),<sp/></highlight><highlight class="stringliteral">&quot;method::instance&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="765"><highlight class="normal"><sp/><sp/><sp/><sp/>.call<sp/>=<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_method_function_call</highlight></codeline>
<codeline lineno="766"><highlight class="normal">);</highlight></codeline>
<codeline lineno="767"><highlight class="normal"></highlight></codeline>
<codeline lineno="768"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ML_TYPED_FN(ml_function_source,<sp/>MLMethodInstanceT,<sp/><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref><sp/>*Instance,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>**Source,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>*Line)<sp/>{</highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>ml_function_source(Instance-&gt;Function,<sp/>Source,<sp/>Line);</highlight></codeline>
<codeline lineno="770"><highlight class="normal">}</highlight></codeline>
<codeline lineno="771"><highlight class="normal"></highlight></codeline>
<codeline lineno="772"><highlight class="normal"><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*ml_method_wrap(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Function,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Count,<sp/><ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**Types)<sp/>{</highlight></codeline>
<codeline lineno="773"><highlight class="normal"><sp/><sp/><sp/><sp/>typeof(ml_method_wrap)<sp/>*function<sp/>=<sp/>ml_typed_fn_get(ml_typeof(Function),<sp/>ml_method_wrap);</highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(function)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>function(Function,<sp/>Count,<sp/>Types);</highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref><sp/>*Instance<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal">(<ref refid="structml__method__instance__t" kindref="compound">ml_method_instance_t</ref>);</highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/>Instance-&gt;Type<sp/>=<sp/>MLMethodInstanceT;</highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/>Instance-&gt;Function<sp/>=<sp/>Function;</highlight></codeline>
<codeline lineno="778"><highlight class="normal"><sp/><sp/><sp/><sp/>Instance-&gt;Types<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/>Instance-&gt;Count<sp/>=<sp/>Count;</highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>(<ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*)Instance;</highlight></codeline>
<codeline lineno="781"><highlight class="normal">}</highlight></codeline>
<codeline lineno="782"><highlight class="normal"></highlight></codeline>
<codeline lineno="783"><highlight class="normal">ML_METHODVX(</highlight><highlight class="stringliteral">&quot;[]&quot;</highlight><highlight class="normal">,<sp/>MLMethodT)<sp/>{</highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*Method<sp/>=<sp/>(<ref refid="structml__method__t" kindref="compound">ml_method_t</ref><sp/>*)Args[0];</highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/>--Count;<sp/>++Args;</highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/>uintptr_t<sp/>Hash<sp/>=<sp/>(uintptr_t)Method;</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>Count;<sp/>--I<sp/>&gt;=<sp/>0;)<sp/>{</highlight></codeline>
<codeline lineno="788"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_CHECKX_ARG_TYPE(I,<sp/>MLTypeT);</highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Args[I]<sp/>=<sp/>ml_deref(Args[I]);</highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Hash<sp/>=<sp/>rotl(Hash,<sp/>1)<sp/>^<sp/>(uintptr_t)Args[I];</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__methods__t" kindref="compound">ml_methods_t</ref><sp/>*Methods<sp/>=<sp/>Caller-&gt;Context-&gt;Values[ML_METHODS_INDEX];</highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__method__cached__t" kindref="compound">ml_method_cached_t</ref><sp/>*Cached<sp/>=<sp/>ml_method_search_entry(Methods,<sp/>Method,<sp/>Count,<sp/>(<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>**)Args,<sp/>Hash);</highlight></codeline>
<codeline lineno="794"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Cached)<sp/>{</highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>Length<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="796"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>Length<sp/>+=<sp/>strlen(((<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)Args[I])-&gt;Name)<sp/>+<sp/>2;</highlight></codeline>
<codeline lineno="797"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Types<sp/>=<sp/>snew(Length);</highlight></codeline>
<codeline lineno="798"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Types[0]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="799"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*P<sp/>=<sp/>Types;</highlight></codeline>
<codeline lineno="800"><highlight class="normal"></highlight><highlight class="preprocessor">#ifdef<sp/>__MINGW32__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="801"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>{</highlight></codeline>
<codeline lineno="802"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/>Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="803"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>strlen(Args[I]-&gt;Type-&gt;Path);</highlight></codeline>
<codeline lineno="804"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(P,<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="805"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P<sp/>+=<sp/>2;</highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="807"><highlight class="normal"></highlight><highlight class="preprocessor">#else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>I<sp/>=<sp/>0;<sp/>I<sp/>&lt;<sp/>Count;<sp/>++I)<sp/>P<sp/>=<sp/>stpcpy(stpcpy(P,<sp/>((<ref refid="structml__type__t" kindref="compound">ml_type_t</ref><sp/>*)Args[I])-&gt;Name),<sp/></highlight><highlight class="stringliteral">&quot;,<sp/>&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight><highlight class="preprocessor">#endif</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>P[-2]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ML_ERROR(</highlight><highlight class="stringliteral">&quot;MethodError&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;no<sp/>method<sp/>found<sp/>for<sp/>%s(%s)&quot;</highlight><highlight class="normal">,<sp/>Method-&gt;Name,<sp/>Types);</highlight></codeline>
<codeline lineno="812"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!Count)<sp/>ML_RETURN(Cached-&gt;Callback);</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/>ML_RETURN(ml_method_wrap(Cached-&gt;Callback,<sp/>Cached-&gt;Count,<sp/>Cached-&gt;Types));</highlight></codeline>
<codeline lineno="815"><highlight class="normal">}</highlight></codeline>
<codeline lineno="816"><highlight class="normal"></highlight></codeline>
<codeline lineno="817"><highlight class="normal"></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>ml_method_list_fn(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*Name,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Method,<sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result)<sp/>{</highlight></codeline>
<codeline lineno="818"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_list_put(Result,<sp/>Method);</highlight></codeline>
<codeline lineno="819"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="820"><highlight class="normal">}</highlight></codeline>
<codeline lineno="821"><highlight class="normal"></highlight></codeline>
<codeline lineno="822"><highlight class="normal">ML_FUNCTION(MLMethodList)<sp/>{</highlight></codeline>
<codeline lineno="823"><highlight class="normal"></highlight><highlight class="comment">//@method::list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="824"><highlight class="normal"></highlight><highlight class="comment">//&gt;list[method]</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="825"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structml__value__t" kindref="compound">ml_value_t</ref><sp/>*Result<sp/>=<sp/>ml_list();</highlight></codeline>
<codeline lineno="826"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_foreach(Methods,<sp/>Result,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)ml_method_list_fn);</highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>Result;</highlight></codeline>
<codeline lineno="828"><highlight class="normal"></highlight></codeline>
<codeline lineno="829"><highlight class="normal">}</highlight></codeline>
<codeline lineno="830"><highlight class="normal"></highlight></codeline>
<codeline lineno="831"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>ml_method_init()<sp/>{</highlight></codeline>
<codeline lineno="832"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_context_set(&amp;MLRootContext,<sp/>ML_METHODS_INDEX,<sp/>MLRootMethods);</highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ml_method_init.c&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="834"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;define&quot;</highlight><highlight class="normal">,<sp/>MLMethodDefine);</highlight></codeline>
<codeline lineno="835"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;switch&quot;</highlight><highlight class="normal">,<sp/>MLMethodSwitch);</highlight></codeline>
<codeline lineno="836"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//stringmap_insert(MLMethodT-&gt;Exports,<sp/>&quot;set&quot;,<sp/>MLMethodSet);</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="837"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;context&quot;</highlight><highlight class="normal">,<sp/>MLMethodContext);</highlight></codeline>
<codeline lineno="838"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;isolate&quot;</highlight><highlight class="normal">,<sp/>MLMethodIsolate);</highlight></codeline>
<codeline lineno="839"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;list&quot;</highlight><highlight class="normal">,<sp/>MLMethodList);</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/>stringmap_insert(MLMethodT-&gt;Exports,<sp/></highlight><highlight class="stringliteral">&quot;default&quot;</highlight><highlight class="normal">,<sp/>MLMethodDefault);</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/>ml_method_by_value(MLMethodT-&gt;Constructor,<sp/>NULL,<sp/>ml_identity,<sp/>MLMethodT,<sp/>NULL);</highlight></codeline>
<codeline lineno="842"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="src/ml_method.c"/>
  </compounddef>
</doxygen>
